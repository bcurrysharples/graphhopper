


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BaseGraph</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.graphhopper.storage</a>
</div>

<h1>Coverage Summary for Class: BaseGraph (com.graphhopper.storage)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BaseGraph</td>
<td class="coverageStat">
  <span class="percent">
    92.6%
  </span>
  <span class="absValue">
    (50/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.2%
  </span>
  <span class="absValue">
    (105/131)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.8%
  </span>
  <span class="absValue">
    (229/255)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BaseGraph$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BaseGraph$AllEdgeIterator</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43.5%
  </span>
  <span class="absValue">
    (10/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BaseGraph$Builder</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.3%
  </span>
  <span class="absValue">
    (21/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BaseGraph$EdgeIteratorImpl</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (15/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (23/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BaseGraph$EdgeIteratorStateImpl</td>
<td class="coverageStat">
  <span class="percent">
    80.9%
  </span>
  <span class="absValue">
    (38/47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.3%
  </span>
  <span class="absValue">
    (27/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.6%
  </span>
  <span class="absValue">
    (98/128)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    87.6%
  </span>
  <span class="absValue">
    (106/121)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75.6%
  </span>
  <span class="absValue">
    (149/197)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.1%
  </span>
  <span class="absValue">
    (382/454)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Licensed to GraphHopper GmbH under one or more contributor
&nbsp; *  license agreements. See the NOTICE file distributed with this work for
&nbsp; *  additional information regarding copyright ownership.
&nbsp; *
&nbsp; *  GraphHopper GmbH licenses this file to you under the Apache License,
&nbsp; *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
&nbsp; *  compliance with the License. You may obtain a copy of the License at
&nbsp; *
&nbsp; *       http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;package com.graphhopper.storage;
&nbsp;
&nbsp;import com.graphhopper.routing.ev.*;
&nbsp;import com.graphhopper.routing.util.AllEdgesIterator;
&nbsp;import com.graphhopper.routing.util.EdgeFilter;
&nbsp;import com.graphhopper.routing.util.EncodingManager;
&nbsp;import com.graphhopper.routing.weighting.Weighting;
&nbsp;import com.graphhopper.search.KVStorage;
&nbsp;import com.graphhopper.util.*;
&nbsp;import com.graphhopper.util.shapes.BBox;
&nbsp;
&nbsp;import java.io.Closeable;
&nbsp;import java.util.Map;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.function.IntConsumer;
&nbsp;
&nbsp;import static com.graphhopper.util.Helper.nf;
&nbsp;import static com.graphhopper.util.Parameters.Details.STREET_NAME;
&nbsp;
&nbsp;/**
&nbsp; * The base graph handles nodes and edges file format. It can be used with different Directory
&nbsp; * implementations like RAMDirectory for fast access or via MMapDirectory for virtual-memory and not
&nbsp; * thread safe usage.
&nbsp; * &lt;p&gt;
&nbsp; * Note: A RAM DataAccess Object is thread-safe in itself but if used in this Graph implementation
&nbsp; * it is not write thread safe.
&nbsp; * &lt;p&gt;
&nbsp; * Life cycle: (1) object creation, (2) configuration via setters &amp;amp; getters, (3) create or
&nbsp; * loadExisting, (4) usage, (5) flush, (6) close
&nbsp; */
<b class="fc">&nbsp;public class BaseGraph implements Graph, Closeable {</b>
&nbsp;    final static long MAX_UNSIGNED_INT = 0xFFFF_FFFFL;
&nbsp;    final BaseGraphNodesAndEdges store;
&nbsp;    final NodeAccess nodeAccess;
&nbsp;    final KVStorage edgeKVStorage;
&nbsp;    // can be null if turn costs are not supported
&nbsp;    final TurnCostStorage turnCostStorage;
&nbsp;    final BitUtil bitUtil;
&nbsp;    // length | nodeA | nextNode | ... | nodeB
&nbsp;    private final DataAccess wayGeometry;
&nbsp;    private final Directory dir;
&nbsp;    private final int segmentSize;
<b class="fc">&nbsp;    private boolean initialized = false;</b>
&nbsp;    private long minGeoRef;
&nbsp;    private long maxGeoRef;
&nbsp;    private final int eleBytesPerCoord;
&nbsp;
<b class="fc">&nbsp;    public BaseGraph(Directory dir, boolean withElevation, boolean withTurnCosts, int segmentSize, int bytesForFlags) {</b>
<b class="fc">&nbsp;        this.dir = dir;</b>
<b class="fc">&nbsp;        this.bitUtil = BitUtil.LITTLE;</b>
<b class="fc">&nbsp;        this.wayGeometry = dir.create(&quot;geometry&quot;, segmentSize);</b>
<b class="fc">&nbsp;        this.edgeKVStorage = new KVStorage(dir, true);</b>
<b class="fc">&nbsp;        this.store = new BaseGraphNodesAndEdges(dir, withElevation, withTurnCosts, segmentSize, bytesForFlags);</b>
<b class="fc">&nbsp;        this.nodeAccess = new GHNodeAccess(store);</b>
<b class="fc">&nbsp;        this.segmentSize = segmentSize;</b>
<b class="fc">&nbsp;        this.turnCostStorage = withTurnCosts ? new TurnCostStorage(this, dir.create(&quot;turn_costs&quot;, dir.getDefaultType(&quot;turn_costs&quot;, true), segmentSize)) : null;</b>
<b class="fc">&nbsp;        this.eleBytesPerCoord = (nodeAccess.getDimension() == 3 ? 3 : 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    BaseGraphNodesAndEdges getStore() {
<b class="fc">&nbsp;        return store;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int getOtherNode(int nodeThis, long edgePointer) {
<b class="fc">&nbsp;        int nodeA = store.getNodeA(edgePointer);</b>
<b class="fc">&nbsp;        return nodeThis == nodeA ? store.getNodeB(edgePointer) : nodeA;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isAdjacentToNode(int node, long edgePointer) {
<b class="fc">&nbsp;        return store.getNodeA(edgePointer) == node || store.getNodeB(edgePointer) == node;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isTestingEnabled() {
<b class="nc">&nbsp;        boolean enableIfAssert = false;</b>
<b class="nc">&nbsp;        assert (enableIfAssert = true) : true;</b>
<b class="nc">&nbsp;        return enableIfAssert;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void debugPrint() {
<b class="nc">&nbsp;        store.debugPrint();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BaseGraph getBaseGraph() {
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isInitialized() {
<b class="fc">&nbsp;        return initialized;</b>
&nbsp;    }
&nbsp;
&nbsp;    void checkNotInitialized() {
<b class="pc">&nbsp;        if (initialized)</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;You cannot configure this BaseGraph &quot;</b>
&nbsp;                    + &quot;after calling create or loadExisting. Calling one of the methods twice is also not allowed.&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private void loadWayGeometryHeader() {
<b class="fc">&nbsp;        int geometryVersion = wayGeometry.getHeader(0);</b>
<b class="fc">&nbsp;        GHUtility.checkDAVersion(wayGeometry.getName(), Constants.VERSION_GEOMETRY, geometryVersion);</b>
<b class="fc">&nbsp;        minGeoRef = bitUtil.toLong(</b>
<b class="fc">&nbsp;                wayGeometry.getHeader(4),</b>
<b class="fc">&nbsp;                wayGeometry.getHeader(8)</b>
&nbsp;        );
<b class="fc">&nbsp;        maxGeoRef = bitUtil.toLong(</b>
<b class="fc">&nbsp;                wayGeometry.getHeader(12),</b>
<b class="fc">&nbsp;                wayGeometry.getHeader(16)</b>
&nbsp;        );
&nbsp;    }
&nbsp;
&nbsp;    private void setWayGeometryHeader() {
<b class="fc">&nbsp;        wayGeometry.setHeader(0, Constants.VERSION_GEOMETRY);</b>
<b class="fc">&nbsp;        wayGeometry.setHeader(4, bitUtil.getIntLow(minGeoRef));</b>
<b class="fc">&nbsp;        wayGeometry.setHeader(8, bitUtil.getIntHigh(minGeoRef));</b>
<b class="fc">&nbsp;        wayGeometry.setHeader(12, bitUtil.getIntLow(maxGeoRef));</b>
<b class="fc">&nbsp;        wayGeometry.setHeader(16, bitUtil.getIntHigh(maxGeoRef));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setInitialized() {
<b class="fc">&nbsp;        initialized = true;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean supportsTurnCosts() {
<b class="fc">&nbsp;        return turnCostStorage != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getNodes() {
<b class="fc">&nbsp;        return store.getNodes();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getEdges() {
<b class="fc">&nbsp;        return store.getEdges();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public NodeAccess getNodeAccess() {
<b class="fc">&nbsp;        return nodeAccess;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public BBox getBounds() {
<b class="fc">&nbsp;        return store.getBounds();</b>
&nbsp;    }
&nbsp;
&nbsp;    public synchronized void freeze() {
<b class="pc">&nbsp;        if (isFrozen())</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;base graph already frozen&quot;);</b>
<b class="fc">&nbsp;        store.setFrozen(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public synchronized boolean isFrozen() {
<b class="fc">&nbsp;        return store.getFrozen();</b>
&nbsp;    }
&nbsp;
&nbsp;    public BaseGraph create(long initSize) {
<b class="fc">&nbsp;        checkNotInitialized();</b>
<b class="fc">&nbsp;        dir.create();</b>
<b class="fc">&nbsp;        store.create(initSize);</b>
&nbsp;
<b class="fc">&nbsp;        initSize = Math.min(initSize, 2000);</b>
<b class="fc">&nbsp;        wayGeometry.create(initSize);</b>
<b class="fc">&nbsp;        edgeKVStorage.create(initSize);</b>
<b class="fc">&nbsp;        if (supportsTurnCosts()) {</b>
<b class="fc">&nbsp;            turnCostStorage.create(initSize);</b>
&nbsp;        }
<b class="fc">&nbsp;        setInitialized();</b>
&nbsp;        // 0 stands for no separate geoRef, &lt;0 stands for no separate geoRef but existing edge copies
<b class="fc">&nbsp;        minGeoRef = -1;</b>
<b class="fc">&nbsp;        maxGeoRef = 1;</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String toDetailsString() {
<b class="fc">&nbsp;        return store.toDetailsString() + &quot;, &quot;</b>
<b class="fc">&nbsp;                + &quot;name:(&quot; + edgeKVStorage.getCapacity() / Helper.MB + &quot;MB), &quot;</b>
<b class="fc">&nbsp;                + &quot;geo:&quot; + nf(maxGeoRef) + &quot;/&quot; + nf(minGeoRef) + &quot;(&quot; + wayGeometry.getCapacity() / Helper.MB + &quot;MB)&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Flush and free resources that are not needed for post-processing (way geometries and KVStorage for edges).
&nbsp;     */
&nbsp;    public void flushAndCloseGeometryAndNameStorage() {
<b class="nc">&nbsp;        setWayGeometryHeader();</b>
&nbsp;
<b class="nc">&nbsp;        wayGeometry.flush();</b>
<b class="nc">&nbsp;        wayGeometry.close();</b>
&nbsp;
<b class="nc">&nbsp;        edgeKVStorage.flush();</b>
<b class="nc">&nbsp;        edgeKVStorage.close();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void flush() {
<b class="pc">&nbsp;        if (!wayGeometry.isClosed()) {</b>
<b class="fc">&nbsp;            setWayGeometryHeader();</b>
<b class="fc">&nbsp;            wayGeometry.flush();</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if (!edgeKVStorage.isClosed())</b>
<b class="fc">&nbsp;            edgeKVStorage.flush();</b>
&nbsp;
<b class="fc">&nbsp;        store.flush();</b>
<b class="fc">&nbsp;        if (supportsTurnCosts()) {</b>
<b class="fc">&nbsp;            turnCostStorage.flush();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void close() {
<b class="pc">&nbsp;        if (!wayGeometry.isClosed())</b>
<b class="fc">&nbsp;            wayGeometry.close();</b>
<b class="pc">&nbsp;        if (!edgeKVStorage.isClosed())</b>
<b class="fc">&nbsp;            edgeKVStorage.close();</b>
<b class="fc">&nbsp;        store.close();</b>
<b class="fc">&nbsp;        if (supportsTurnCosts()) {</b>
<b class="fc">&nbsp;            turnCostStorage.close();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public long getCapacity() {
<b class="nc">&nbsp;        return store.getCapacity() + edgeKVStorage.getCapacity()</b>
<b class="nc">&nbsp;                + wayGeometry.getCapacity() + (supportsTurnCosts() ? turnCostStorage.getCapacity() : 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    long getMaxGeoRef() {
<b class="fc">&nbsp;        return maxGeoRef;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean loadExisting() {
<b class="fc">&nbsp;        checkNotInitialized();</b>
&nbsp;
<b class="pc">&nbsp;        if (!store.loadExisting())</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;
<b class="pc">&nbsp;        if (!wayGeometry.loadExisting())</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;
<b class="pc">&nbsp;        if (!edgeKVStorage.loadExisting())</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;
<b class="pc">&nbsp;        if (supportsTurnCosts() &amp;&amp; !turnCostStorage.loadExisting())</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;
<b class="fc">&nbsp;        setInitialized();</b>
<b class="fc">&nbsp;        loadWayGeometryHeader();</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method copies the properties of one {@link EdgeIteratorState} to another.
&nbsp;     *
&nbsp;     * @return the updated iterator the properties where copied to.
&nbsp;     */
&nbsp;    EdgeIteratorState copyProperties(EdgeIteratorState from, EdgeIteratorStateImpl to) {
<b class="fc">&nbsp;        long edgePointer = store.toEdgePointer(to.getEdge());</b>
<b class="fc">&nbsp;        store.writeFlags(edgePointer, from.getFlags());</b>
&nbsp;
&nbsp;        // copy the rest with higher level API
<b class="fc">&nbsp;        to.setDistance(from.getDistance()).</b>
<b class="fc">&nbsp;                setKeyValues(from.getKeyValues()).</b>
<b class="fc">&nbsp;                setWayGeometry(from.fetchWayGeometry(FetchMode.PILLAR_ONLY));</b>
&nbsp;
<b class="fc">&nbsp;        return to;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create edge between nodes a and b
&nbsp;     *
&nbsp;     * @return EdgeIteratorState of newly created edge
&nbsp;     */
&nbsp;    @Override
&nbsp;    public EdgeIteratorState edge(int nodeA, int nodeB) {
<b class="pc">&nbsp;        if (isFrozen())</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot create edge if graph is already frozen&quot;);</b>
<b class="pc">&nbsp;        if (nodeA == nodeB)</b>
&nbsp;            // Loop edges would only make sense if their attributes were the same for both &#39;directions&#39;,
&nbsp;            // because for routing algorithms (which ignore the way geometry) loop edges do not even
&nbsp;            // have a well-defined &#39;direction&#39;. So we either need to make sure the attributes
&nbsp;            // are the same for both directions, or reject loop edges altogether. Since we currently
&nbsp;            // don&#39;t know any use-case for loop edges in road networks (there is one for PT),
&nbsp;            // we reject them here.
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Loop edges are not supported, got: &quot; + nodeA + &quot; - &quot; + nodeB);</b>
<b class="fc">&nbsp;        int edgeId = store.edge(nodeA, nodeB);</b>
<b class="fc">&nbsp;        EdgeIteratorStateImpl edge = new EdgeIteratorStateImpl(this);</b>
<b class="fc">&nbsp;        boolean valid = edge.init(edgeId, nodeB);</b>
<b class="pc">&nbsp;        assert valid;</b>
<b class="fc">&nbsp;        return edge;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a copy of a given edge with the same properties.
&nbsp;     *
&nbsp;     * @param reuseGeometry If true the copy uses the same pointer to the geometry,
&nbsp;     *                      so changing the geometry would alter the geometry for both edges!
&nbsp;     */
&nbsp;    public EdgeIteratorState copyEdge(int edge, boolean reuseGeometry) {
<b class="fc">&nbsp;        EdgeIteratorStateImpl edgeState = (EdgeIteratorStateImpl) getEdgeIteratorState(edge, Integer.MIN_VALUE);</b>
<b class="fc">&nbsp;        EdgeIteratorStateImpl newEdge = (EdgeIteratorStateImpl) edge(edgeState.getBaseNode(), edgeState.getAdjNode())</b>
<b class="fc">&nbsp;                .setFlags(edgeState.getFlags())</b>
<b class="fc">&nbsp;                .setDistance(edgeState.getDistance())</b>
<b class="fc">&nbsp;                .setKeyValues(edgeState.getKeyValues());</b>
<b class="fc">&nbsp;        if (reuseGeometry) {</b>
&nbsp;            // We use the same geo ref for the copied edge. This saves memory because we are not duplicating
&nbsp;            // the geometry, and it allows to identify the copies of a given edge.
<b class="fc">&nbsp;            long edgePointer = edgeState.edgePointer;</b>
<b class="fc">&nbsp;            long geoRef = store.getGeoRef(edgePointer);</b>
<b class="fc">&nbsp;            if (geoRef == 0) {</b>
&nbsp;                // No geometry for this edge, but we need to be able to identify the copied edges later, so
&nbsp;                // we use a dedicated negative value for the geo ref.
<b class="fc">&nbsp;                geoRef = minGeoRef;</b>
<b class="fc">&nbsp;                store.setGeoRef(edgePointer, geoRef);</b>
<b class="fc">&nbsp;                minGeoRef--;</b>
&nbsp;            }
<b class="fc">&nbsp;            store.setGeoRef(newEdge.edgePointer, geoRef);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            newEdge.setWayGeometry(edgeState.fetchWayGeometry(FetchMode.PILLAR_ONLY));</b>
&nbsp;        }
<b class="fc">&nbsp;        return newEdge;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs the given action on the given edge and all its copies that were created with &#39;reuseGeometry=true&#39;.
&nbsp;     */
&nbsp;    public void forEdgeAndCopiesOfEdge(EdgeExplorer explorer, EdgeIteratorState edge, Consumer&lt;EdgeIteratorState&gt; consumer) {
<b class="fc">&nbsp;        final long geoRef = store.getGeoRef(((EdgeIteratorStateImpl) edge).edgePointer);</b>
<b class="fc">&nbsp;        if (geoRef == 0) {</b>
&nbsp;            // 0 means there is no geometry (and no copy of this edge), but of course not all edges
&nbsp;            // without geometry are copies of each other, so we need to return early
<b class="fc">&nbsp;            consumer.accept(edge);</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        EdgeIterator iter = explorer.setBaseNode(edge.getBaseNode());</b>
<b class="fc">&nbsp;        while (iter.next()) {</b>
<b class="fc">&nbsp;            long geoRefBefore = store.getGeoRef(((EdgeIteratorStateImpl) iter).edgePointer);</b>
<b class="fc">&nbsp;            if (geoRefBefore == geoRef)</b>
<b class="fc">&nbsp;                consumer.accept(iter);</b>
<b class="pc">&nbsp;            if (store.getGeoRef(((EdgeIteratorStateImpl) iter).edgePointer) != geoRefBefore)</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;The consumer must not change the geo ref&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void forEdgeAndCopiesOfEdge(EdgeExplorer explorer, int node, int edge, IntConsumer consumer) {
<b class="fc">&nbsp;        final long geoRef = store.getGeoRef(store.toEdgePointer(edge));</b>
<b class="fc">&nbsp;        if (geoRef == 0) {</b>
&nbsp;            // 0 means there is no geometry (and no copy of this edge), but of course not all edges
&nbsp;            // without geometry are copies of each other, so we need to return early
<b class="fc">&nbsp;            consumer.accept(edge);</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        EdgeIterator iter = explorer.setBaseNode(node);</b>
<b class="fc">&nbsp;        while (iter.next()) {</b>
<b class="fc">&nbsp;            long geoRefBefore = store.getGeoRef(((EdgeIteratorStateImpl) iter).edgePointer);</b>
<b class="fc">&nbsp;            if (geoRefBefore == geoRef)</b>
<b class="fc">&nbsp;                consumer.accept(iter.getEdge());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
<b class="fc">&nbsp;        EdgeIteratorStateImpl edge = new EdgeIteratorStateImpl(this);</b>
<b class="fc">&nbsp;        if (edge.init(edgeId, adjNode))</b>
<b class="fc">&nbsp;            return edge;</b>
&nbsp;        // if edgeId exists but adjacent nodes do not match
<b class="fc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public EdgeIteratorState getEdgeIteratorStateForKey(int edgeKey) {
<b class="fc">&nbsp;        EdgeIteratorStateImpl edge = new EdgeIteratorStateImpl(this);</b>
<b class="fc">&nbsp;        edge.init(edgeKey);</b>
<b class="fc">&nbsp;        return edge;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
<b class="fc">&nbsp;        return new EdgeIteratorImpl(this, filter);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public EdgeExplorer createEdgeExplorer() {
<b class="fc">&nbsp;        return createEdgeExplorer(EdgeFilter.ALL_EDGES);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public AllEdgesIterator getAllEdges() {
<b class="fc">&nbsp;        return new AllEdgeIterator(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public TurnCostStorage getTurnCostStorage() {
<b class="fc">&nbsp;        return turnCostStorage;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Weighting wrapWeighting(Weighting weighting) {
<b class="fc">&nbsp;        return weighting;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getOtherNode(int edge, int node) {
<b class="fc">&nbsp;        long edgePointer = store.toEdgePointer(edge);</b>
<b class="fc">&nbsp;        return getOtherNode(node, edgePointer);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isAdjacentToNode(int edge, int node) {
<b class="fc">&nbsp;        long edgePointer = store.toEdgePointer(edge);</b>
<b class="fc">&nbsp;        return isAdjacentToNode(node, edgePointer);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return true if the specified node is the adjacent node of the specified edge
&nbsp;     * (relative to the direction in which the edge is stored).
&nbsp;     */
&nbsp;    public boolean isAdjNode(int edge, int node) {
<b class="fc">&nbsp;        long edgePointer = store.toEdgePointer(edge);</b>
<b class="fc">&nbsp;        return node == store.getNodeB(edgePointer);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setWayGeometry_(PointList pillarNodes, long edgePointer, boolean reverse) {
<b class="pc">&nbsp;        if (pillarNodes != null &amp;&amp; !pillarNodes.isEmpty()) {</b>
<b class="pc">&nbsp;            if (pillarNodes.getDimension() != nodeAccess.getDimension())</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot use pointlist which is &quot; + pillarNodes.getDimension()</b>
<b class="nc">&nbsp;                        + &quot;D for graph which is &quot; + nodeAccess.getDimension() + &quot;D&quot;);</b>
&nbsp;
<b class="fc">&nbsp;            long existingGeoRef = store.getGeoRef(edgePointer);</b>
<b class="fc">&nbsp;            if (existingGeoRef &lt; 0)</b>
&nbsp;                // users of this method might not be aware that after changing the geo ref it is no
&nbsp;                // longer possible to find the copies corresponding to an edge, so we deny this
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;This edge has already been copied so we can no longer change the geometry, pointer=&quot; + edgePointer);</b>
&nbsp;
<b class="fc">&nbsp;            int len = pillarNodes.size();</b>
<b class="fc">&nbsp;            if (existingGeoRef &gt; 0) {</b>
<b class="fc">&nbsp;                final int count = getPillarCount(existingGeoRef);</b>
<b class="fc">&nbsp;                if (len &lt;= count) {</b>
<b class="fc">&nbsp;                    setWayGeometryAtGeoRef(pillarNodes, edgePointer, reverse, existingGeoRef);</b>
&nbsp;                    return;
&nbsp;                } else {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;This edge already has a way geometry so it cannot be changed to a bigger geometry, pointer=&quot; + edgePointer);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            long nextGeoRef = nextGeoRef(3 + len * (8 + eleBytesPerCoord));</b>
<b class="fc">&nbsp;            setWayGeometryAtGeoRef(pillarNodes, edgePointer, reverse, nextGeoRef);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            store.setGeoRef(edgePointer, 0L);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public EdgeIntAccess getEdgeAccess() {
<b class="fc">&nbsp;        return store;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setWayGeometryAtGeoRef(PointList pillarNodes, long edgePointer, boolean reverse, long geoRef) {
<b class="fc">&nbsp;        byte[] wayGeometryBytes = createWayGeometryBytes(pillarNodes, reverse);</b>
<b class="fc">&nbsp;        wayGeometry.ensureCapacity(geoRef + wayGeometryBytes.length);</b>
<b class="fc">&nbsp;        wayGeometry.setBytes(geoRef, wayGeometryBytes, wayGeometryBytes.length);</b>
<b class="fc">&nbsp;        store.setGeoRef(edgePointer, geoRef);</b>
&nbsp;    }
&nbsp;
&nbsp;    private byte[] createWayGeometryBytes(PointList pillarNodes, boolean reverse) {
<b class="fc">&nbsp;        int len = pillarNodes.size();</b>
<b class="fc">&nbsp;        int totalLen = 3 + len * (8 + eleBytesPerCoord);</b>
<b class="pc">&nbsp;        if ((totalLen &amp; 0xFF00_0000) != 0)</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;too long way geometry &quot; + totalLen + &quot;, &quot; + len);</b>
&nbsp;
<b class="fc">&nbsp;        byte[] bytes = new byte[totalLen];</b>
<b class="fc">&nbsp;        bitUtil.fromUInt3(bytes, len, 0);</b>
<b class="pc">&nbsp;        if (reverse)</b>
<b class="nc">&nbsp;            pillarNodes.reverse();</b>
&nbsp;
<b class="fc">&nbsp;        int tmpOffset = 3;</b>
<b class="fc">&nbsp;        boolean is3D = nodeAccess.is3D();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; len; i++) {</b>
<b class="fc">&nbsp;            double lat = pillarNodes.getLat(i);</b>
<b class="fc">&nbsp;            bitUtil.fromInt(bytes, Helper.degreeToInt(lat), tmpOffset);</b>
<b class="fc">&nbsp;            tmpOffset += 4;</b>
<b class="fc">&nbsp;            bitUtil.fromInt(bytes, Helper.degreeToInt(pillarNodes.getLon(i)), tmpOffset);</b>
<b class="fc">&nbsp;            tmpOffset += 4;</b>
&nbsp;
<b class="fc">&nbsp;            if (is3D) {</b>
<b class="fc">&nbsp;                bitUtil.fromUInt3(bytes, Helper.eleToUInt(pillarNodes.getEle(i)), tmpOffset);</b>
<b class="fc">&nbsp;                tmpOffset += 3;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return bytes;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int getPillarCount(long geoRef) {
<b class="fc">&nbsp;        return (wayGeometry.getByte(geoRef + 2) &amp; 0xFF &lt;&lt; 16) | wayGeometry.getShort(geoRef);</b>
&nbsp;    }
&nbsp;
&nbsp;    private PointList fetchWayGeometry_(long edgePointer, boolean reverse, FetchMode mode, int baseNode, int adjNode) {
<b class="fc">&nbsp;        if (mode == FetchMode.TOWER_ONLY) {</b>
&nbsp;            // no reverse handling required as adjNode and baseNode is already properly switched
<b class="fc">&nbsp;            PointList pillarNodes = new PointList(2, nodeAccess.is3D());</b>
<b class="fc">&nbsp;            pillarNodes.add(nodeAccess, baseNode);</b>
<b class="fc">&nbsp;            pillarNodes.add(nodeAccess, adjNode);</b>
<b class="fc">&nbsp;            return pillarNodes;</b>
&nbsp;        }
<b class="fc">&nbsp;        long geoRef = store.getGeoRef(edgePointer);</b>
<b class="fc">&nbsp;        int count = 0;</b>
<b class="fc">&nbsp;        byte[] bytes = null;</b>
<b class="fc">&nbsp;        if (geoRef &gt; 0) {</b>
<b class="fc">&nbsp;            count = getPillarCount(geoRef);</b>
<b class="fc">&nbsp;            geoRef += 3L;</b>
<b class="fc">&nbsp;            bytes = new byte[count * (8 + eleBytesPerCoord)];</b>
<b class="fc">&nbsp;            wayGeometry.getBytes(geoRef, bytes, bytes.length);</b>
<b class="fc">&nbsp;        } else if (mode == FetchMode.PILLAR_ONLY)</b>
<b class="fc">&nbsp;            return PointList.EMPTY;</b>
&nbsp;
<b class="fc">&nbsp;        PointList pillarNodes = new PointList(getPointListLength(count, mode), nodeAccess.is3D());</b>
<b class="fc">&nbsp;        if (reverse) {</b>
<b class="fc">&nbsp;            if (mode == FetchMode.ALL || mode == FetchMode.PILLAR_AND_ADJ)</b>
<b class="fc">&nbsp;                pillarNodes.add(nodeAccess, adjNode);</b>
<b class="fc">&nbsp;        } else if (mode == FetchMode.ALL || mode == FetchMode.BASE_AND_PILLAR)</b>
<b class="fc">&nbsp;            pillarNodes.add(nodeAccess, baseNode);</b>
&nbsp;
<b class="fc">&nbsp;        int index = 0;</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="fc">&nbsp;            double lat = Helper.intToDegree(bitUtil.toInt(bytes, index));</b>
<b class="fc">&nbsp;            index += 4;</b>
<b class="fc">&nbsp;            double lon = Helper.intToDegree(bitUtil.toInt(bytes, index));</b>
<b class="fc">&nbsp;            index += 4;</b>
<b class="fc">&nbsp;            if (nodeAccess.is3D()) {</b>
<b class="fc">&nbsp;                pillarNodes.add(lat, lon, Helper.uIntToEle(bitUtil.toUInt3(bytes, index)));</b>
<b class="fc">&nbsp;                index += 3;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                pillarNodes.add(lat, lon);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (reverse) {</b>
<b class="fc">&nbsp;            if (mode == FetchMode.ALL || mode == FetchMode.BASE_AND_PILLAR)</b>
<b class="fc">&nbsp;                pillarNodes.add(nodeAccess, baseNode);</b>
&nbsp;
<b class="fc">&nbsp;            pillarNodes.reverse();</b>
<b class="fc">&nbsp;        } else if (mode == FetchMode.ALL || mode == FetchMode.PILLAR_AND_ADJ)</b>
<b class="fc">&nbsp;            pillarNodes.add(nodeAccess, adjNode);</b>
&nbsp;
<b class="fc">&nbsp;        return pillarNodes;</b>
&nbsp;    }
&nbsp;
&nbsp;    static int getPointListLength(int pillarNodes, FetchMode mode) {
<b class="pc">&nbsp;        switch (mode) {</b>
&nbsp;            case TOWER_ONLY:
<b class="nc">&nbsp;                return 2;</b>
&nbsp;            case PILLAR_ONLY:
<b class="fc">&nbsp;                return pillarNodes;</b>
&nbsp;            case BASE_AND_PILLAR:
&nbsp;            case PILLAR_AND_ADJ:
<b class="fc">&nbsp;                return pillarNodes + 1;</b>
&nbsp;            case ALL:
<b class="fc">&nbsp;                return pillarNodes + 2;</b>
&nbsp;        }
<b class="nc">&nbsp;        throw new IllegalArgumentException(&quot;Mode isn&#39;t handled &quot; + mode);</b>
&nbsp;    }
&nbsp;
&nbsp;    private long nextGeoRef(int bytes) {
<b class="fc">&nbsp;        long tmp = maxGeoRef;</b>
<b class="fc">&nbsp;        maxGeoRef += bytes;</b>
<b class="fc">&nbsp;        return tmp;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isClosed() {
<b class="fc">&nbsp;        return store.isClosed();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Directory getDirectory() {
<b class="fc">&nbsp;        return dir;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getSegmentSize() {
<b class="fc">&nbsp;        return segmentSize;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Builder {
&nbsp;        private final int bytesForFlags;
<b class="fc">&nbsp;        private Directory directory = new RAMDirectory();</b>
<b class="fc">&nbsp;        private boolean withElevation = false;</b>
<b class="fc">&nbsp;        private boolean withTurnCosts = false;</b>
<b class="fc">&nbsp;        private long bytes = 100;</b>
<b class="fc">&nbsp;        private int segmentSize = -1;</b>
&nbsp;
&nbsp;        public Builder(EncodingManager em) {
<b class="fc">&nbsp;            this(em.getBytesForFlags());</b>
<b class="fc">&nbsp;            withTurnCosts(em.needsTurnCostsSupport());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public Builder(int bytesForFlags) {</b>
<b class="fc">&nbsp;            this.bytesForFlags = bytesForFlags;</b>
&nbsp;        }
&nbsp;
&nbsp;        // todo: maybe rename later, but for now this makes it easier to replace GraphBuilder
&nbsp;        public Builder setDir(Directory directory) {
<b class="fc">&nbsp;            this.directory = directory;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        // todo: maybe rename later, but for now this makes it easier to replace GraphBuilder
&nbsp;        public Builder set3D(boolean withElevation) {
<b class="fc">&nbsp;            this.withElevation = withElevation;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        // todo: maybe rename later, but for now this makes it easier to replace GraphBuilder
&nbsp;        public Builder withTurnCosts(boolean withTurnCosts) {
<b class="fc">&nbsp;            this.withTurnCosts = withTurnCosts;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder setSegmentSize(int segmentSize) {
<b class="fc">&nbsp;            this.segmentSize = segmentSize;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder setBytes(long bytes) {
<b class="nc">&nbsp;            this.bytes = bytes;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public BaseGraph build() {
<b class="fc">&nbsp;            return new BaseGraph(directory, withElevation, withTurnCosts, segmentSize, bytesForFlags);</b>
&nbsp;        }
&nbsp;
&nbsp;        public BaseGraph create() {
<b class="fc">&nbsp;            BaseGraph baseGraph = build();</b>
<b class="fc">&nbsp;            baseGraph.create(bytes);</b>
<b class="fc">&nbsp;            return baseGraph;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    protected static class EdgeIteratorImpl extends EdgeIteratorStateImpl implements EdgeExplorer, EdgeIterator {</b>
&nbsp;        final EdgeFilter filter;
&nbsp;        int nextEdgeId;
&nbsp;
&nbsp;        public EdgeIteratorImpl(BaseGraph baseGraph, EdgeFilter filter) {
<b class="fc">&nbsp;            super(baseGraph);</b>
<b class="pc">&nbsp;            if (filter == null)</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Instead null filter use EdgeFilter.ALL_EDGES&quot;);</b>
<b class="fc">&nbsp;            this.filter = filter;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIterator setBaseNode(int baseNode) {
<b class="fc">&nbsp;            nextEdgeId = edgeId = store.getEdgeRef(store.toNodePointer(baseNode));</b>
<b class="fc">&nbsp;            this.baseNode = baseNode;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final boolean next() {
<b class="fc">&nbsp;            while (EdgeIterator.Edge.isValid(nextEdgeId)) {</b>
<b class="fc">&nbsp;                goToNext();</b>
<b class="fc">&nbsp;                if (filter.accept(this))</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;            }
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        void goToNext() {
<b class="fc">&nbsp;            edgePointer = store.toEdgePointer(nextEdgeId);</b>
<b class="fc">&nbsp;            edgeId = nextEdgeId;</b>
<b class="fc">&nbsp;            int nodeA = store.getNodeA(edgePointer);</b>
<b class="fc">&nbsp;            boolean baseNodeIsNodeA = baseNode == nodeA;</b>
<b class="fc">&nbsp;            adjNode = baseNodeIsNodeA ? store.getNodeB(edgePointer) : nodeA;</b>
<b class="fc">&nbsp;            reverse = !baseNodeIsNodeA;</b>
&nbsp;
&nbsp;            // position to next edge
<b class="fc">&nbsp;            nextEdgeId = baseNodeIsNodeA ? store.getLinkA(edgePointer) : store.getLinkB(edgePointer);</b>
<b class="pc">&nbsp;            assert nextEdgeId != edgeId : (&quot;endless loop detected for base node: &quot; + baseNode + &quot;, adj node: &quot; + adjNode</b>
&nbsp;                    + &quot;, edge pointer: &quot; + edgePointer + &quot;, edge: &quot; + edgeId);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState detach(boolean reverseArg) {
<b class="fc">&nbsp;            if (edgeId == nextEdgeId)</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;call next before detaching (edgeId:&quot; + edgeId + &quot; vs. next &quot; + nextEdgeId + &quot;)&quot;);</b>
<b class="fc">&nbsp;            return super.detach(reverseArg);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Include all edges of this storage in the iterator.
&nbsp;     */
&nbsp;    protected static class AllEdgeIterator extends EdgeIteratorStateImpl implements AllEdgesIterator {
&nbsp;        public AllEdgeIterator(BaseGraph baseGraph) {
<b class="fc">&nbsp;            super(baseGraph);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int length() {
<b class="fc">&nbsp;            return store.getEdges();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean next() {
<b class="fc">&nbsp;            edgeId++;</b>
<b class="fc">&nbsp;            if (edgeId &gt;= store.getEdges())</b>
<b class="fc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            edgePointer = store.toEdgePointer(edgeId);</b>
<b class="fc">&nbsp;            baseNode = store.getNodeA(edgePointer);</b>
<b class="fc">&nbsp;            adjNode = store.getNodeB(edgePointer);</b>
<b class="fc">&nbsp;            reverse = false;</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final EdgeIteratorState detach(boolean reverseArg) {
<b class="nc">&nbsp;            if (edgePointer &lt; 0)</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;call next before detaching&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            AllEdgeIterator iter = new AllEdgeIterator(baseGraph);</b>
<b class="nc">&nbsp;            iter.edgeId = edgeId;</b>
<b class="nc">&nbsp;            iter.edgePointer = edgePointer;</b>
<b class="nc">&nbsp;            if (reverseArg) {</b>
<b class="nc">&nbsp;                iter.reverse = !this.reverse;</b>
<b class="nc">&nbsp;                iter.baseNode = adjNode;</b>
<b class="nc">&nbsp;                iter.adjNode = baseNode;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                iter.reverse = this.reverse;</b>
<b class="nc">&nbsp;                iter.baseNode = baseNode;</b>
<b class="nc">&nbsp;                iter.adjNode = adjNode;</b>
&nbsp;            }
<b class="nc">&nbsp;            return iter;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    static class EdgeIteratorStateImpl implements EdgeIteratorState {</b>
&nbsp;        final BaseGraph baseGraph;
&nbsp;        final BaseGraphNodesAndEdges store;
<b class="fc">&nbsp;        long edgePointer = -1;</b>
&nbsp;        int baseNode;
&nbsp;        int adjNode;
&nbsp;        // we need reverse if detach is called
<b class="fc">&nbsp;        boolean reverse = false;</b>
<b class="fc">&nbsp;        int edgeId = -1;</b>
&nbsp;        private final EdgeIntAccess edgeIntAccess;
&nbsp;
<b class="fc">&nbsp;        public EdgeIteratorStateImpl(BaseGraph baseGraph) {</b>
<b class="fc">&nbsp;            this.baseGraph = baseGraph;</b>
<b class="fc">&nbsp;            edgeIntAccess = baseGraph.getEdgeAccess();</b>
<b class="fc">&nbsp;            store = baseGraph.store;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @return false if the edge has not a node equal to expectedAdjNode
&nbsp;         */
&nbsp;        final boolean init(int edgeId, int expectedAdjNode) {
<b class="fc">&nbsp;            if (edgeId &lt; 0 || edgeId &gt;= store.getEdges())</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;edge: &quot; + edgeId + &quot; out of bounds: [0,&quot; + store.getEdges() + &quot;[&quot;);</b>
<b class="fc">&nbsp;            this.edgeId = edgeId;</b>
<b class="fc">&nbsp;            edgePointer = store.toEdgePointer(edgeId);</b>
<b class="fc">&nbsp;            baseNode = store.getNodeA(edgePointer);</b>
<b class="fc">&nbsp;            adjNode = store.getNodeB(edgePointer);</b>
&nbsp;
<b class="fc">&nbsp;            if (expectedAdjNode == adjNode || expectedAdjNode == Integer.MIN_VALUE) {</b>
<b class="fc">&nbsp;                reverse = false;</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (expectedAdjNode == baseNode) {</b>
<b class="fc">&nbsp;                reverse = true;</b>
<b class="fc">&nbsp;                baseNode = adjNode;</b>
<b class="fc">&nbsp;                adjNode = expectedAdjNode;</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Similar to {@link #init(int edgeId, int adjNode)}, but here we retrieve the edge in a certain direction
&nbsp;         * directly using an edge key.
&nbsp;         */
&nbsp;        final void init(int edgeKey) {
<b class="pc">&nbsp;            if (edgeKey &lt; 0)</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;edge keys must not be negative, given: &quot; + edgeKey);</b>
<b class="fc">&nbsp;            this.edgeId = GHUtility.getEdgeFromEdgeKey(edgeKey);</b>
<b class="fc">&nbsp;            edgePointer = store.toEdgePointer(edgeId);</b>
<b class="fc">&nbsp;            baseNode = store.getNodeA(edgePointer);</b>
<b class="fc">&nbsp;            adjNode = store.getNodeB(edgePointer);</b>
&nbsp;
<b class="fc">&nbsp;            if (edgeKey % 2 == 0) {</b>
<b class="fc">&nbsp;                reverse = false;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                reverse = true;</b>
<b class="fc">&nbsp;                int tmp = baseNode;</b>
<b class="fc">&nbsp;                baseNode = adjNode;</b>
<b class="fc">&nbsp;                adjNode = tmp;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final int getBaseNode() {
<b class="fc">&nbsp;            return baseNode;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final int getAdjNode() {
<b class="fc">&nbsp;            return adjNode;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public double getDistance() {
<b class="fc">&nbsp;            return store.getDist(edgePointer);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState setDistance(double dist) {
<b class="fc">&nbsp;            store.setDist(edgePointer, dist);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public IntsRef getFlags() {
<b class="fc">&nbsp;            IntsRef edgeFlags = store.createEdgeFlags();</b>
<b class="fc">&nbsp;            store.readFlags(edgePointer, edgeFlags);</b>
<b class="fc">&nbsp;            return edgeFlags;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final EdgeIteratorState setFlags(IntsRef edgeFlags) {
<b class="pc">&nbsp;            assert edgeId &lt; store.getEdges() : &quot;must be edge but was shortcut: &quot; + edgeId + &quot; &gt;= &quot; + store.getEdges() + &quot;. Use setFlagsAndWeight&quot;;</b>
<b class="fc">&nbsp;            store.writeFlags(edgePointer, edgeFlags);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean get(BooleanEncodedValue property) {
<b class="fc">&nbsp;            return property.getBool(reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
<b class="fc">&nbsp;            property.setBool(reverse, edgeId, edgeIntAccess, value);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean getReverse(BooleanEncodedValue property) {
<b class="fc">&nbsp;            return property.getBool(!reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
<b class="fc">&nbsp;            property.setBool(!reverse, edgeId, edgeIntAccess, value);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState set(BooleanEncodedValue property, boolean fwd, boolean bwd) {
<b class="pc">&nbsp;            if (!property.isStoreTwoDirections())</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;EncodedValue &quot; + property.getName() + &quot; supports only one direction&quot;);</b>
<b class="fc">&nbsp;            property.setBool(reverse, edgeId, edgeIntAccess, fwd);</b>
<b class="fc">&nbsp;            property.setBool(!reverse, edgeId, edgeIntAccess, bwd);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int get(IntEncodedValue property) {
<b class="fc">&nbsp;            return property.getInt(reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState set(IntEncodedValue property, int value) {
<b class="fc">&nbsp;            property.setInt(reverse, edgeId, edgeIntAccess, value);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getReverse(IntEncodedValue property) {
<b class="fc">&nbsp;            return property.getInt(!reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
<b class="nc">&nbsp;            property.setInt(!reverse, edgeId, edgeIntAccess, value);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState set(IntEncodedValue property, int fwd, int bwd) {
<b class="nc">&nbsp;            if (!property.isStoreTwoDirections())</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;EncodedValue &quot; + property.getName() + &quot; supports only one direction&quot;);</b>
<b class="nc">&nbsp;            property.setInt(reverse, edgeId, edgeIntAccess, fwd);</b>
<b class="nc">&nbsp;            property.setInt(!reverse, edgeId, edgeIntAccess, bwd);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public double get(DecimalEncodedValue property) {
<b class="fc">&nbsp;            return property.getDecimal(reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState set(DecimalEncodedValue property, double value) {
<b class="fc">&nbsp;            property.setDecimal(reverse, edgeId, edgeIntAccess, value);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public double getReverse(DecimalEncodedValue property) {
<b class="fc">&nbsp;            return property.getDecimal(!reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
<b class="fc">&nbsp;            property.setDecimal(!reverse, edgeId, edgeIntAccess, value);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState set(DecimalEncodedValue property, double fwd, double bwd) {
<b class="pc">&nbsp;            if (!property.isStoreTwoDirections())</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;EncodedValue &quot; + property.getName() + &quot; supports only one direction&quot;);</b>
<b class="fc">&nbsp;            property.setDecimal(reverse, edgeId, edgeIntAccess, fwd);</b>
<b class="fc">&nbsp;            property.setDecimal(!reverse, edgeId, edgeIntAccess, bwd);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T extends Enum&lt;?&gt;&gt; T get(EnumEncodedValue&lt;T&gt; property) {
<b class="fc">&nbsp;            return property.getEnum(reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T extends Enum&lt;?&gt;&gt; EdgeIteratorState set(EnumEncodedValue&lt;T&gt; property, T value) {
<b class="fc">&nbsp;            property.setEnum(reverse, edgeId, edgeIntAccess, value);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T extends Enum&lt;?&gt;&gt; T getReverse(EnumEncodedValue&lt;T&gt; property) {
<b class="fc">&nbsp;            return property.getEnum(!reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T extends Enum&lt;?&gt;&gt; EdgeIteratorState setReverse(EnumEncodedValue&lt;T&gt; property, T value) {
<b class="nc">&nbsp;            property.setEnum(!reverse, edgeId, edgeIntAccess, value);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T extends Enum&lt;?&gt;&gt; EdgeIteratorState set(EnumEncodedValue&lt;T&gt; property, T fwd, T bwd) {
<b class="nc">&nbsp;            if (!property.isStoreTwoDirections())</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;EncodedValue &quot; + property.getName() + &quot; supports only one direction&quot;);</b>
<b class="nc">&nbsp;            property.setEnum(reverse, edgeId, edgeIntAccess, fwd);</b>
<b class="nc">&nbsp;            property.setEnum(!reverse, edgeId, edgeIntAccess, bwd);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String get(StringEncodedValue property) {
<b class="nc">&nbsp;            return property.getString(reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState set(StringEncodedValue property, String value) {
<b class="nc">&nbsp;            property.setString(reverse, edgeId, edgeIntAccess, value);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getReverse(StringEncodedValue property) {
<b class="nc">&nbsp;            return property.getString(!reverse, edgeId, edgeIntAccess);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState setReverse(StringEncodedValue property, String value) {
<b class="nc">&nbsp;            property.setString(!reverse, edgeId, edgeIntAccess, value);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState set(StringEncodedValue property, String fwd, String bwd) {
<b class="nc">&nbsp;            if (!property.isStoreTwoDirections())</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;EncodedValue &quot; + property.getName() + &quot; supports only one direction&quot;);</b>
<b class="nc">&nbsp;            property.setString(reverse, edgeId, edgeIntAccess, fwd);</b>
<b class="nc">&nbsp;            property.setString(!reverse, edgeId, edgeIntAccess, bwd);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final EdgeIteratorState copyPropertiesFrom(EdgeIteratorState edge) {
<b class="fc">&nbsp;            return baseGraph.copyProperties(edge, this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState setWayGeometry(PointList pillarNodes) {
<b class="fc">&nbsp;            baseGraph.setWayGeometry_(pillarNodes, edgePointer, reverse);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PointList fetchWayGeometry(FetchMode mode) {
<b class="fc">&nbsp;            return baseGraph.fetchWayGeometry_(edgePointer, reverse, mode, getBaseNode(), getAdjNode());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getEdge() {
<b class="fc">&nbsp;            return edgeId;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getEdgeKey() {
<b class="fc">&nbsp;            return GHUtility.createEdgeKey(edgeId, reverse);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getReverseEdgeKey() {
<b class="fc">&nbsp;            return GHUtility.reverseEdgeKey(getEdgeKey());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState setKeyValues(Map&lt;String, KVStorage.KValue&gt; entries) {
<b class="fc">&nbsp;            long pointer = baseGraph.edgeKVStorage.add(entries);</b>
<b class="pc">&nbsp;            if (pointer &gt; MAX_UNSIGNED_INT)</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Too many key value pairs are stored, currently limited to &quot; + MAX_UNSIGNED_INT + &quot; was &quot; + pointer);</b>
<b class="fc">&nbsp;            store.setKeyValuesRef(edgePointer, BitUtil.toSignedInt(pointer));</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Map&lt;String, KVStorage.KValue&gt; getKeyValues() {
<b class="fc">&nbsp;            long kvEntryRef = Integer.toUnsignedLong(store.getKeyValuesRef(edgePointer));</b>
<b class="fc">&nbsp;            return baseGraph.edgeKVStorage.getAll(kvEntryRef);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Object getValue(String key) {
<b class="fc">&nbsp;            long kvEntryRef = Integer.toUnsignedLong(store.getKeyValuesRef(edgePointer));</b>
<b class="fc">&nbsp;            return baseGraph.edgeKVStorage.get(kvEntryRef, key, reverse);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="fc">&nbsp;            String name = (String) getValue(STREET_NAME);</b>
&nbsp;            // preserve backward compatibility (returns empty string if name tag missing)
<b class="fc">&nbsp;            return name == null ? &quot;&quot; : name;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public EdgeIteratorState detach(boolean reverseArg) {
<b class="pc">&nbsp;            if (!EdgeIterator.Edge.isValid(edgeId))</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;call setEdgeId before detaching (edgeId:&quot; + edgeId + &quot;)&quot;);</b>
<b class="fc">&nbsp;            EdgeIteratorStateImpl edge = new EdgeIteratorStateImpl(baseGraph);</b>
<b class="fc">&nbsp;            boolean valid = edge.init(edgeId, reverseArg ? baseNode : adjNode);</b>
<b class="pc">&nbsp;            assert valid;</b>
<b class="fc">&nbsp;            if (reverseArg) {</b>
&nbsp;                // for #162
<b class="fc">&nbsp;                edge.reverse = !reverse;</b>
&nbsp;            }
<b class="fc">&nbsp;            return edge;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final String toString() {
<b class="fc">&nbsp;            return getEdge() + &quot; &quot; + getBaseNode() + &quot;-&quot; + getAdjNode();</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-09-30 17:20</div>
</div>
</body>
</html>
