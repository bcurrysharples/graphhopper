


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MapMatching</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.graphhopper.matching</a>
</div>

<h1>Coverage Summary for Class: MapMatching (com.graphhopper.matching)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MapMatching</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/134)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/245)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MapMatching$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapMatching$1$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapMatching$1$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapMatching$Label</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapMatching$MapMatchedPath</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapMatching$Router</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/146)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/281)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Licensed to GraphHopper GmbH under one or more contributor
&nbsp; *  license agreements. See the NOTICE file distributed with this work for
&nbsp; *  additional information regarding copyright ownership.
&nbsp; *
&nbsp; *  GraphHopper GmbH licenses this file to you under the Apache License,
&nbsp; *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
&nbsp; *  compliance with the License. You may obtain a copy of the License at
&nbsp; *
&nbsp; *       http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;package com.graphhopper.matching;
&nbsp;
&nbsp;import com.carrotsearch.hppc.IntHashSet;
&nbsp;import com.graphhopper.GraphHopper;
&nbsp;import com.graphhopper.config.Profile;
&nbsp;import com.graphhopper.routing.AStarBidirection;
&nbsp;import com.graphhopper.routing.DijkstraBidirectionRef;
&nbsp;import com.graphhopper.routing.Path;
&nbsp;import com.graphhopper.routing.ev.BooleanEncodedValue;
&nbsp;import com.graphhopper.routing.ev.Subnetwork;
&nbsp;import com.graphhopper.routing.lm.LMApproximator;
&nbsp;import com.graphhopper.routing.lm.LandmarkStorage;
&nbsp;import com.graphhopper.routing.querygraph.QueryGraph;
&nbsp;import com.graphhopper.routing.querygraph.VirtualEdgeIteratorState;
&nbsp;import com.graphhopper.routing.util.DefaultSnapFilter;
&nbsp;import com.graphhopper.routing.util.EdgeFilter;
&nbsp;import com.graphhopper.routing.util.TraversalMode;
&nbsp;import com.graphhopper.routing.weighting.Weighting;
&nbsp;import com.graphhopper.storage.BaseGraph;
&nbsp;import com.graphhopper.storage.Graph;
&nbsp;import com.graphhopper.storage.index.LocationIndexTree;
&nbsp;import com.graphhopper.storage.index.Snap;
&nbsp;import com.graphhopper.util.*;
&nbsp;import com.graphhopper.util.shapes.BBox;
&nbsp;import org.locationtech.jts.geom.Envelope;
&nbsp;
&nbsp;import java.util.*;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.IntStream;
&nbsp;
&nbsp;import static com.graphhopper.util.DistancePlaneProjection.DIST_PLANE;
&nbsp;
&nbsp;/**
&nbsp; * This class matches real world GPX entries to the digital road network stored
&nbsp; * in GraphHopper. The Viterbi algorithm is used to compute the most likely
&nbsp; * sequence of map matching candidates. The Viterbi algorithm takes into account
&nbsp; * the distance between GPX entries and map matching candidates as well as the
&nbsp; * routing distances between consecutive map matching candidates.
&nbsp; * &lt;p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * See http://en.wikipedia.org/wiki/Map_matching and Newson, Paul, and John
&nbsp; * Krumm. &quot;Hidden Markov map matching through noise and sparseness.&quot; Proceedings
&nbsp; * of the 17th ACM SIGSPATIAL International Conference on Advances in Geographic
&nbsp; * Information Systems. ACM, 2009.
&nbsp; *
&nbsp; * @author Peter Karich
&nbsp; * @author Michael Zilske
&nbsp; * @author Stefan Holder
&nbsp; * @author kodonnell
&nbsp; */
&nbsp;public class MapMatching {
&nbsp;    private final BaseGraph graph;
&nbsp;    private final Router router;
&nbsp;    private final LocationIndexTree locationIndex;
<b class="nc">&nbsp;    private double measurementErrorSigma = 10.0;</b>
<b class="nc">&nbsp;    private double transitionProbabilityBeta = 2.0;</b>
<b class="nc">&nbsp;    private final DistanceCalc distanceCalc = new DistancePlaneProjection();</b>
&nbsp;    private QueryGraph queryGraph;
&nbsp;
<b class="nc">&nbsp;    private Map&lt;String, Object&gt; statistics = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    public static MapMatching fromGraphHopper(GraphHopper graphHopper, PMap hints) {
<b class="nc">&nbsp;        Router router = routerFromGraphHopper(graphHopper, hints);</b>
<b class="nc">&nbsp;        return new MapMatching(graphHopper.getBaseGraph(), (LocationIndexTree) graphHopper.getLocationIndex(), router);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Router routerFromGraphHopper(GraphHopper graphHopper, PMap hints) {
<b class="nc">&nbsp;        if (hints.has(&quot;vehicle&quot;))</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;MapMatching hints may no longer contain a vehicle, use the profile parameter instead, see core/#1958&quot;);</b>
<b class="nc">&nbsp;        if (hints.has(&quot;weighting&quot;))</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;MapMatching hints may no longer contain a weighting, use the profile parameter instead, see core/#1958&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        if (graphHopper.getProfiles().isEmpty()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;No profiles found, you need to configure at least one profile to use map matching&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!hints.has(&quot;profile&quot;)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;You need to specify a profile to perform map matching&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        String profileStr = hints.getString(&quot;profile&quot;, &quot;&quot;);</b>
<b class="nc">&nbsp;        Profile profile = graphHopper.getProfile(profileStr);</b>
<b class="nc">&nbsp;        if (profile == null) {</b>
<b class="nc">&nbsp;            List&lt;Profile&gt; profiles = graphHopper.getProfiles();</b>
<b class="nc">&nbsp;            List&lt;String&gt; profileNames = new ArrayList&lt;&gt;(profiles.size());</b>
<b class="nc">&nbsp;            for (Profile p : profiles) {</b>
<b class="nc">&nbsp;                profileNames.add(p.getName());</b>
&nbsp;            }
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Could not find profile &#39;&quot; + profileStr + &quot;&#39;, choose one of: &quot; + profileNames);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean disableLM = hints.getBool(Parameters.Landmark.DISABLE, false);</b>
<b class="nc">&nbsp;        boolean disableCH = hints.getBool(Parameters.CH.DISABLE, false);</b>
&nbsp;
&nbsp;        // see map-matching/#177: both ch.disable and lm.disable can be used to force Dijkstra which is the better
&nbsp;        // (=faster) choice when the observations are close to each other
<b class="nc">&nbsp;        boolean useDijkstra = disableLM || disableCH;</b>
&nbsp;
&nbsp;        LandmarkStorage landmarks;
<b class="nc">&nbsp;        if (!useDijkstra &amp;&amp; graphHopper.getLandmarks().get(profile.getName()) != null) {</b>
&nbsp;            // using LM because u-turn prevention does not work properly with (node-based) CH
<b class="nc">&nbsp;            landmarks = graphHopper.getLandmarks().get(profile.getName());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            landmarks = null;</b>
&nbsp;        }
<b class="nc">&nbsp;        Weighting weighting = graphHopper.createWeighting(profile, hints);</b>
<b class="nc">&nbsp;        BooleanEncodedValue inSubnetworkEnc = graphHopper.getEncodingManager().getBooleanEncodedValue(Subnetwork.key(profileStr));</b>
<b class="nc">&nbsp;        DefaultSnapFilter snapFilter = new DefaultSnapFilter(weighting, inSubnetworkEnc);</b>
<b class="nc">&nbsp;        int maxVisitedNodes = hints.getInt(Parameters.Routing.MAX_VISITED_NODES, Integer.MAX_VALUE);</b>
&nbsp;
<b class="nc">&nbsp;        Router router = new Router() {</b>
&nbsp;            @Override
&nbsp;            public EdgeFilter getSnapFilter() {
<b class="nc">&nbsp;                return snapFilter;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public List&lt;Path&gt; calcPaths(QueryGraph queryGraph, int fromNode, int fromOutEdge, int[] toNodes, int[] toInEdges) {
<b class="nc">&nbsp;                assert (toNodes.length == toInEdges.length);</b>
<b class="nc">&nbsp;                List&lt;Path&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; toNodes.length; i++) {</b>
<b class="nc">&nbsp;                    result.add(calcOnePath(queryGraph, fromNode, toNodes[i], fromOutEdge, toInEdges[i]));</b>
&nbsp;                }
<b class="nc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;
&nbsp;            private Path calcOnePath(QueryGraph queryGraph, int fromNode, int toNode, int fromOutEdge, int toInEdge) {
<b class="nc">&nbsp;                Weighting queryGraphWeighting = queryGraph.wrapWeighting(weighting);</b>
<b class="nc">&nbsp;                if (landmarks != null) {</b>
<b class="nc">&nbsp;                    AStarBidirection aStarBidirection = new AStarBidirection(queryGraph, queryGraphWeighting, TraversalMode.EDGE_BASED) {</b>
&nbsp;                        @Override
&nbsp;                        protected void initCollections(int size) {
<b class="nc">&nbsp;                            super.initCollections(50);</b>
&nbsp;                        }
&nbsp;                    };
<b class="nc">&nbsp;                    int activeLM = Math.min(8, landmarks.getLandmarkCount());</b>
<b class="nc">&nbsp;                    LMApproximator lmApproximator = LMApproximator.forLandmarks(queryGraph, queryGraphWeighting, landmarks, activeLM);</b>
<b class="nc">&nbsp;                    aStarBidirection.setApproximation(lmApproximator);</b>
<b class="nc">&nbsp;                    aStarBidirection.setMaxVisitedNodes(maxVisitedNodes);</b>
<b class="nc">&nbsp;                    return aStarBidirection.calcPath(fromNode, toNode, fromOutEdge, toInEdge);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    DijkstraBidirectionRef dijkstraBidirectionRef = new DijkstraBidirectionRef(queryGraph, queryGraphWeighting, TraversalMode.EDGE_BASED) {</b>
&nbsp;                        @Override
&nbsp;                        protected void initCollections(int size) {
<b class="nc">&nbsp;                            super.initCollections(50);</b>
&nbsp;                        }
&nbsp;                    };
<b class="nc">&nbsp;                    dijkstraBidirectionRef.setMaxVisitedNodes(maxVisitedNodes);</b>
<b class="nc">&nbsp;                    return dijkstraBidirectionRef.calcPath(fromNode, toNode, fromOutEdge, toInEdge);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Weighting getWeighting() {
<b class="nc">&nbsp;                return weighting;</b>
&nbsp;            }
&nbsp;        };
<b class="nc">&nbsp;        return router;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public MapMatching(BaseGraph graph, LocationIndexTree locationIndex, Router router) {</b>
<b class="nc">&nbsp;        this.graph = graph;</b>
<b class="nc">&nbsp;        this.locationIndex = locationIndex;</b>
<b class="nc">&nbsp;        this.router = router;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Beta parameter of the exponential distribution for modeling transition
&nbsp;     * probabilities.
&nbsp;     */
&nbsp;    public void setTransitionProbabilityBeta(double transitionProbabilityBeta) {
<b class="nc">&nbsp;        this.transitionProbabilityBeta = transitionProbabilityBeta;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Standard deviation of the normal distribution [m] used for modeling the
&nbsp;     * GPS error.
&nbsp;     */
&nbsp;    public void setMeasurementErrorSigma(double measurementErrorSigma) {
<b class="nc">&nbsp;        this.measurementErrorSigma = measurementErrorSigma;</b>
&nbsp;    }
&nbsp;
&nbsp;    public MatchResult match(List&lt;Observation&gt; observations) {
<b class="nc">&nbsp;        List&lt;Observation&gt; filteredObservations = filterObservations(observations);</b>
<b class="nc">&nbsp;        statistics.put(&quot;filteredObservations&quot;, filteredObservations.size());</b>
&nbsp;
&nbsp;        // Snap observations to links. Generates multiple candidate snaps per observation.
<b class="nc">&nbsp;        List&lt;List&lt;Snap&gt;&gt; snapsPerObservation = filteredObservations.stream()</b>
<b class="nc">&nbsp;                .map(o -&gt; findCandidateSnaps(o.getPoint().lat, o.getPoint().lon))</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
<b class="nc">&nbsp;        statistics.put(&quot;snapsPerObservation&quot;, snapsPerObservation.stream().mapToInt(Collection::size).toArray());</b>
&nbsp;
&nbsp;        // Create the query graph, containing split edges so that all the places where an observation might have happened
&nbsp;        // are a node. This modifies the Snap objects and puts the new node numbers into them.
<b class="nc">&nbsp;        queryGraph = QueryGraph.create(graph, snapsPerObservation.stream().flatMap(Collection::stream).collect(Collectors.toList()));</b>
&nbsp;
&nbsp;        // Creates candidates from the Snaps of all observations (a candidate is basically a
&nbsp;        // Snap + direction).
<b class="nc">&nbsp;        List&lt;ObservationWithCandidateStates&gt; timeSteps = createTimeSteps(filteredObservations, snapsPerObservation);</b>
&nbsp;
&nbsp;        // Compute the most likely sequence of map matching candidates:
<b class="nc">&nbsp;        List&lt;SequenceState&lt;State, Observation, Path&gt;&gt; seq = computeViterbiSequence(timeSteps);</b>
<b class="nc">&nbsp;        statistics.put(&quot;transitionDistances&quot;, seq.stream().filter(s -&gt; s.transitionDescriptor != null).mapToLong(s -&gt; Math.round(s.transitionDescriptor.getDistance())).toArray());</b>
<b class="nc">&nbsp;        statistics.put(&quot;visitedNodes&quot;, router.getVisitedNodes());</b>
<b class="nc">&nbsp;        statistics.put(&quot;snapDistanceRanks&quot;, IntStream.range(0, seq.size()).map(i -&gt; snapsPerObservation.get(i).indexOf(seq.get(i).state.getSnap())).toArray());</b>
<b class="nc">&nbsp;        statistics.put(&quot;snapDistances&quot;, seq.stream().mapToDouble(s -&gt; s.state.getSnap().getQueryDistance()).toArray());</b>
<b class="nc">&nbsp;        statistics.put(&quot;maxSnapDistances&quot;, IntStream.range(0, seq.size()).mapToDouble(i -&gt; snapsPerObservation.get(i).stream().mapToDouble(Snap::getQueryDistance).max().orElse(-1.0)).toArray());</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;EdgeIteratorState&gt; path = seq.stream().filter(s1 -&gt; s1.transitionDescriptor != null).flatMap(s1 -&gt; s1.transitionDescriptor.calcEdges().stream()).collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;        MatchResult result = new MatchResult(prepareEdgeMatches(seq));</b>
<b class="nc">&nbsp;        Weighting queryGraphWeighting = queryGraph.wrapWeighting(router.getWeighting());</b>
<b class="nc">&nbsp;        result.setMergedPath(new MapMatchedPath(queryGraph, queryGraphWeighting, path));</b>
<b class="nc">&nbsp;        result.setMatchMillis(seq.stream().filter(s -&gt; s.transitionDescriptor != null).mapToLong(s -&gt; s.transitionDescriptor.getTime()).sum());</b>
<b class="nc">&nbsp;        result.setMatchLength(seq.stream().filter(s -&gt; s.transitionDescriptor != null).mapToDouble(s -&gt; s.transitionDescriptor.getDistance()).sum());</b>
<b class="nc">&nbsp;        result.setGPXEntriesLength(gpxLength(observations));</b>
<b class="nc">&nbsp;        result.setGraph(queryGraph);</b>
<b class="nc">&nbsp;        result.setWeighting(queryGraphWeighting);</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filters observations to only those which will be used for map matching (i.e. those which
&nbsp;     * are separated by at least 2 * measurementErrorSigman
&nbsp;     */
&nbsp;    public List&lt;Observation&gt; filterObservations(List&lt;Observation&gt; observations) {
<b class="nc">&nbsp;        List&lt;Observation&gt; filtered = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        Observation prevEntry = null;</b>
<b class="nc">&nbsp;        double acc = 0.0;</b>
<b class="nc">&nbsp;        int last = observations.size() - 1;</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt;= last; i++) {</b>
<b class="nc">&nbsp;            Observation observation = observations.get(i);</b>
<b class="nc">&nbsp;            if (i == 0 || i == last || distanceCalc.calcDist(</b>
<b class="nc">&nbsp;                    prevEntry.getPoint().getLat(), prevEntry.getPoint().getLon(),</b>
<b class="nc">&nbsp;                    observation.getPoint().getLat(), observation.getPoint().getLon()) &gt; 2 * measurementErrorSigma) {</b>
<b class="nc">&nbsp;                if (i &gt; 0) {</b>
<b class="nc">&nbsp;                    Observation prevObservation = observations.get(i - 1);</b>
<b class="nc">&nbsp;                    acc += distanceCalc.calcDist(</b>
<b class="nc">&nbsp;                            prevObservation.getPoint().getLat(), prevObservation.getPoint().getLon(),</b>
<b class="nc">&nbsp;                            observation.getPoint().getLat(), observation.getPoint().getLon());</b>
<b class="nc">&nbsp;                    acc -= distanceCalc.calcDist(</b>
<b class="nc">&nbsp;                            prevEntry.getPoint().getLat(), prevEntry.getPoint().getLon(),</b>
<b class="nc">&nbsp;                            observation.getPoint().getLat(), observation.getPoint().getLon());</b>
&nbsp;                }
&nbsp;                // Here we store the meters of distance that we are missing because of the filtering,
&nbsp;                // so that when we add these terms to the distances between the filtered points,
&nbsp;                // the original total distance between the unfiltered points is conserved.
&nbsp;                // (See test for kind of a specification.)
<b class="nc">&nbsp;                observation.setAccumulatedLinearDistanceToPrevious(acc);</b>
<b class="nc">&nbsp;                filtered.add(observation);</b>
<b class="nc">&nbsp;                prevEntry = observation;</b>
<b class="nc">&nbsp;                acc = 0.0;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                Observation prevObservation = observations.get(i - 1);</b>
<b class="nc">&nbsp;                acc += distanceCalc.calcDist(</b>
<b class="nc">&nbsp;                        prevObservation.getPoint().getLat(), prevObservation.getPoint().getLon(),</b>
<b class="nc">&nbsp;                        observation.getPoint().getLat(), observation.getPoint().getLon());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return filtered;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Snap&gt; findCandidateSnaps(final double queryLat, final double queryLon) {
<b class="nc">&nbsp;        double rLon = (measurementErrorSigma * 360.0 / DistanceCalcEarth.DIST_EARTH.calcCircumference(queryLat));</b>
<b class="nc">&nbsp;        double rLat = measurementErrorSigma / DistanceCalcEarth.METERS_PER_DEGREE;</b>
<b class="nc">&nbsp;        Envelope envelope = new Envelope(queryLon, queryLon, queryLat, queryLat);</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; 50; i++) {</b>
<b class="nc">&nbsp;            envelope.expandBy(rLon, rLat);</b>
<b class="nc">&nbsp;            List&lt;Snap&gt; snaps = findCandidateSnapsInBBox(queryLat, queryLon, BBox.fromEnvelope(envelope));</b>
<b class="nc">&nbsp;            if (!snaps.isEmpty()) {</b>
<b class="nc">&nbsp;                return snaps;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return Collections.emptyList();</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;Snap&gt; findCandidateSnapsInBBox(double queryLat, double queryLon, BBox queryShape) {
<b class="nc">&nbsp;        EdgeFilter edgeFilter = router.getSnapFilter();</b>
<b class="nc">&nbsp;        List&lt;Snap&gt; snaps = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        IntHashSet seenEdges = new IntHashSet();</b>
<b class="nc">&nbsp;        IntHashSet seenNodes = new IntHashSet();</b>
<b class="nc">&nbsp;        locationIndex.query(queryShape, edgeId -&gt; {</b>
<b class="nc">&nbsp;            EdgeIteratorState edge = graph.getEdgeIteratorStateForKey(edgeId * 2);</b>
<b class="nc">&nbsp;            if (seenEdges.add(edgeId) &amp;&amp; edgeFilter.accept(edge)) {</b>
<b class="nc">&nbsp;                Snap snap = new Snap(queryLat, queryLon);</b>
<b class="nc">&nbsp;                locationIndex.traverseEdge(queryLat, queryLon, edge, (node, normedDist, wayIndex, pos) -&gt; {</b>
<b class="nc">&nbsp;                    if (normedDist &lt; snap.getQueryDistance()) {</b>
<b class="nc">&nbsp;                        snap.setQueryDistance(normedDist);</b>
<b class="nc">&nbsp;                        snap.setClosestNode(node);</b>
<b class="nc">&nbsp;                        snap.setWayIndex(wayIndex);</b>
<b class="nc">&nbsp;                        snap.setSnappedPosition(pos);</b>
&nbsp;                    }
&nbsp;                });
<b class="nc">&nbsp;                double dist = DIST_PLANE.calcDenormalizedDist(snap.getQueryDistance());</b>
<b class="nc">&nbsp;                snap.setClosestEdge(edge);</b>
<b class="nc">&nbsp;                snap.setQueryDistance(dist);</b>
<b class="nc">&nbsp;                if (snap.isValid() &amp;&amp; (snap.getSnappedPosition() != Snap.Position.TOWER || seenNodes.add(snap.getClosestNode()))) {</b>
<b class="nc">&nbsp;                    snap.calcSnappedPoint(DistanceCalcEarth.DIST_EARTH);</b>
<b class="nc">&nbsp;                    if (queryShape.contains(snap.getSnappedPoint().lat, snap.getSnappedPoint().lon)) {</b>
<b class="nc">&nbsp;                        snaps.add(snap);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        snaps.sort(Comparator.comparingDouble(Snap::getQueryDistance));</b>
<b class="nc">&nbsp;        return snaps;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates TimeSteps with candidates for the GPX entries but does not create emission or
&nbsp;     * transition probabilities. Creates directed candidates for virtual nodes and undirected
&nbsp;     * candidates for real nodes.
&nbsp;     */
&nbsp;    private List&lt;ObservationWithCandidateStates&gt; createTimeSteps(List&lt;Observation&gt; filteredObservations, List&lt;List&lt;Snap&gt;&gt; splitsPerObservation) {
<b class="nc">&nbsp;        if (splitsPerObservation.size() != filteredObservations.size()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(</b>
&nbsp;                    &quot;filteredGPXEntries and queriesPerEntry must have same size.&quot;);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final List&lt;ObservationWithCandidateStates&gt; timeSteps = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; filteredObservations.size(); i++) {</b>
<b class="nc">&nbsp;            Observation observation = filteredObservations.get(i);</b>
<b class="nc">&nbsp;            Collection&lt;Snap&gt; splits = splitsPerObservation.get(i);</b>
<b class="nc">&nbsp;            List&lt;State&gt; candidates = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Snap split : splits) {</b>
<b class="nc">&nbsp;                if (queryGraph.isVirtualNode(split.getClosestNode())) {</b>
<b class="nc">&nbsp;                    List&lt;VirtualEdgeIteratorState&gt; virtualEdges = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                    EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(split.getClosestNode());</b>
<b class="nc">&nbsp;                    while (iter.next()) {</b>
<b class="nc">&nbsp;                        if (!queryGraph.isVirtualEdge(iter.getEdge())) {</b>
<b class="nc">&nbsp;                            throw new RuntimeException(&quot;Virtual nodes must only have virtual edges &quot;</b>
&nbsp;                                    + &quot;to adjacent nodes.&quot;);
&nbsp;                        }
<b class="nc">&nbsp;                        virtualEdges.add((VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(iter.getEdge(), iter.getAdjNode()));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (virtualEdges.size() != 2) {</b>
<b class="nc">&nbsp;                        throw new RuntimeException(&quot;Each virtual node must have exactly 2 &quot;</b>
&nbsp;                                + &quot;virtual edges (reverse virtual edges are not returned by the &quot;
&nbsp;                                + &quot;EdgeIterator&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    // Create a directed candidate for each of the two possible directions through
&nbsp;                    // the virtual node. We need to add candidates for both directions because
&nbsp;                    // we don&#39;t know yet which is the correct one. This will be figured
&nbsp;                    // out by the Viterbi algorithm.
<b class="nc">&nbsp;                    candidates.add(new State(observation, split, virtualEdges.get(0), virtualEdges.get(1)));</b>
<b class="nc">&nbsp;                    candidates.add(new State(observation, split, virtualEdges.get(1), virtualEdges.get(0)));</b>
&nbsp;                } else {
&nbsp;                    // Create an undirected candidate for the real node.
<b class="nc">&nbsp;                    candidates.add(new State(observation, split));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            timeSteps.add(new ObservationWithCandidateStates(observation, candidates));</b>
&nbsp;        }
<b class="nc">&nbsp;        return timeSteps;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    static class Label {</b>
&nbsp;        int timeStep;
&nbsp;        State state;
&nbsp;        Label back;
&nbsp;        boolean isDeleted;
&nbsp;        double minusLogProbability;
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;SequenceState&lt;State, Observation, Path&gt;&gt; computeViterbiSequence(List&lt;ObservationWithCandidateStates&gt; timeSteps) {
<b class="nc">&nbsp;        if (timeSteps.isEmpty()) {</b>
<b class="nc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final HmmProbabilities probabilities = new HmmProbabilities(measurementErrorSigma, transitionProbabilityBeta);</b>
<b class="nc">&nbsp;        final Map&lt;State, Label&gt; labels = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        Map&lt;Transition&lt;State&gt;, Path&gt; roadPaths = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        PriorityQueue&lt;Label&gt; q = new PriorityQueue&lt;&gt;(Comparator.comparing(qe -&gt; qe.minusLogProbability));</b>
<b class="nc">&nbsp;        for (State candidate : timeSteps.get(0).candidates) {</b>
&nbsp;            // distance from observation to road in meters
<b class="nc">&nbsp;            final double distance = candidate.getSnap().getQueryDistance();</b>
<b class="nc">&nbsp;            Label label = new Label();</b>
<b class="nc">&nbsp;            label.state = candidate;</b>
<b class="nc">&nbsp;            label.minusLogProbability = probabilities.emissionLogProbability(distance) * -1.0;</b>
<b class="nc">&nbsp;            q.add(label);</b>
<b class="nc">&nbsp;            labels.put(candidate, label);</b>
&nbsp;        }
<b class="nc">&nbsp;        Label qe = null;</b>
<b class="nc">&nbsp;        while (!q.isEmpty()) {</b>
<b class="nc">&nbsp;            qe = q.poll();</b>
<b class="nc">&nbsp;            if (qe.isDeleted)</b>
&nbsp;                continue;
<b class="nc">&nbsp;            if (qe.timeStep == timeSteps.size() - 1)</b>
&nbsp;                break;
<b class="nc">&nbsp;            State from = qe.state;</b>
<b class="nc">&nbsp;            ObservationWithCandidateStates timeStep = timeSteps.get(qe.timeStep);</b>
<b class="nc">&nbsp;            ObservationWithCandidateStates nextTimeStep = timeSteps.get(qe.timeStep + 1);</b>
<b class="nc">&nbsp;            final double linearDistance = distanceCalc.calcDist(timeStep.observation.getPoint().lat, timeStep.observation.getPoint().lon,</b>
<b class="nc">&nbsp;                    nextTimeStep.observation.getPoint().lat, nextTimeStep.observation.getPoint().lon)</b>
<b class="nc">&nbsp;                    + nextTimeStep.observation.getAccumulatedLinearDistanceToPrevious();</b>
<b class="nc">&nbsp;            int fromNode = from.getSnap().getClosestNode();</b>
<b class="nc">&nbsp;            int fromOutEdge = from.isOnDirectedEdge() ? from.getOutgoingVirtualEdge().getEdge() : EdgeIterator.ANY_EDGE;</b>
<b class="nc">&nbsp;            int[] toNodes = nextTimeStep.candidates.stream().mapToInt(c -&gt; c.getSnap().getClosestNode()).toArray();</b>
<b class="nc">&nbsp;            int[] toInEdges = nextTimeStep.candidates.stream().mapToInt(to -&gt; to.isOnDirectedEdge() ? to.getIncomingVirtualEdge().getEdge() : EdgeIterator.ANY_EDGE).toArray();</b>
<b class="nc">&nbsp;            List&lt;Path&gt; paths = router.calcPaths(queryGraph, fromNode, fromOutEdge, toNodes, toInEdges);</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; nextTimeStep.candidates.size(); i++) {</b>
<b class="nc">&nbsp;                State to = nextTimeStep.candidates.get(i);</b>
<b class="nc">&nbsp;                Path path = paths.get(i);</b>
<b class="nc">&nbsp;                if (path.isFound()) {</b>
<b class="nc">&nbsp;                    double transitionLogProbability = probabilities.transitionLogProbability(path.getDistance(), linearDistance);</b>
<b class="nc">&nbsp;                    Transition&lt;State&gt; transition = new Transition&lt;&gt;(from, to);</b>
<b class="nc">&nbsp;                    roadPaths.put(transition, path);</b>
<b class="nc">&nbsp;                    double minusLogProbability = qe.minusLogProbability - probabilities.emissionLogProbability(to.getSnap().getQueryDistance()) - transitionLogProbability;</b>
<b class="nc">&nbsp;                    Label label1 = labels.get(to);</b>
<b class="nc">&nbsp;                    if (label1 == null || minusLogProbability &lt; label1.minusLogProbability) {</b>
<b class="nc">&nbsp;                        q.stream().filter(oldQe -&gt; !oldQe.isDeleted &amp;&amp; oldQe.state == to).findFirst().ifPresent(oldQe -&gt; oldQe.isDeleted = true);</b>
<b class="nc">&nbsp;                        Label label = new Label();</b>
<b class="nc">&nbsp;                        label.state = to;</b>
<b class="nc">&nbsp;                        label.timeStep = qe.timeStep + 1;</b>
<b class="nc">&nbsp;                        label.back = qe;</b>
<b class="nc">&nbsp;                        label.minusLogProbability = minusLogProbability;</b>
<b class="nc">&nbsp;                        q.add(label);</b>
<b class="nc">&nbsp;                        labels.put(to, label);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (qe == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Sequence is broken for submitted track at initial time step.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (qe.timeStep != timeSteps.size() - 1) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Sequence is broken for submitted track at time step &quot;</b>
<b class="nc">&nbsp;                    + qe.timeStep + &quot;. observation:&quot; + qe.state.getEntry());</b>
&nbsp;        }
<b class="nc">&nbsp;        ArrayList&lt;SequenceState&lt;State, Observation, Path&gt;&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        while (qe != null) {</b>
<b class="nc">&nbsp;            final SequenceState&lt;State, Observation, Path&gt; ss = new SequenceState&lt;&gt;(qe.state, qe.state.getEntry(), qe.back == null ? null : roadPaths.get(new Transition&lt;&gt;(qe.back.state, qe.state)));</b>
<b class="nc">&nbsp;            result.add(ss);</b>
<b class="nc">&nbsp;            qe = qe.back;</b>
&nbsp;        }
<b class="nc">&nbsp;        Collections.reverse(result);</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;EdgeMatch&gt; prepareEdgeMatches(List&lt;SequenceState&lt;State, Observation, Path&gt;&gt; seq) {
&nbsp;        // This creates a list of directed edges (EdgeIteratorState instances turned the right way),
&nbsp;        // each associated with 0 or more of the observations.
&nbsp;        // These directed edges are edges of the real street graph, where nodes are intersections.
&nbsp;        // So in _this_ representation, the path that you get when you just look at the edges goes from
&nbsp;        // an intersection to an intersection.
&nbsp;
&nbsp;        // Implementation note: We have to look at both states _and_ transitions, since we can have e.g. just one state,
&nbsp;        // or two states with a transition that is an empty path (observations snapped to the same node in the query graph),
&nbsp;        // but these states still happen on an edge, and for this representation, we want to have that edge.
&nbsp;        // (Whereas in the ResponsePath representation, we would just see an empty path.)
&nbsp;
&nbsp;        // Note that the result can be empty, even when the input is not. Observations can be on nodes as well as on
&nbsp;        // edges, and when all observations are on the same node, we get no edge at all.
&nbsp;        // But apart from that corner case, all observations that go in here are also in the result.
&nbsp;
&nbsp;        // (Consider totally forbidding candidate states to be snapped to a point, and make them all be on directed
&nbsp;        // edges, then that corner case goes away.)
<b class="nc">&nbsp;        List&lt;EdgeMatch&gt; edgeMatches = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        List&lt;State&gt; states = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        EdgeIteratorState currentDirectedRealEdge = null;</b>
<b class="nc">&nbsp;        for (SequenceState&lt;State, Observation, Path&gt; transitionAndState : seq) {</b>
&nbsp;            // transition (except before the first state)
<b class="nc">&nbsp;            if (transitionAndState.transitionDescriptor != null) {</b>
<b class="nc">&nbsp;                for (EdgeIteratorState edge : transitionAndState.transitionDescriptor.calcEdges()) {</b>
<b class="nc">&nbsp;                    EdgeIteratorState newDirectedRealEdge = resolveToRealEdge(edge);</b>
<b class="nc">&nbsp;                    if (currentDirectedRealEdge != null) {</b>
<b class="nc">&nbsp;                        if (!equalEdges(currentDirectedRealEdge, newDirectedRealEdge)) {</b>
<b class="nc">&nbsp;                            EdgeMatch edgeMatch = new EdgeMatch(currentDirectedRealEdge, states);</b>
<b class="nc">&nbsp;                            edgeMatches.add(edgeMatch);</b>
<b class="nc">&nbsp;                            states = new ArrayList&lt;&gt;();</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    currentDirectedRealEdge = newDirectedRealEdge;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // state
<b class="nc">&nbsp;            if (transitionAndState.state.isOnDirectedEdge()) { // as opposed to on a node</b>
<b class="nc">&nbsp;                EdgeIteratorState newDirectedRealEdge = resolveToRealEdge(transitionAndState.state.getOutgoingVirtualEdge());</b>
<b class="nc">&nbsp;                if (currentDirectedRealEdge != null) {</b>
<b class="nc">&nbsp;                    if (!equalEdges(currentDirectedRealEdge, newDirectedRealEdge)) {</b>
<b class="nc">&nbsp;                        EdgeMatch edgeMatch = new EdgeMatch(currentDirectedRealEdge, states);</b>
<b class="nc">&nbsp;                        edgeMatches.add(edgeMatch);</b>
<b class="nc">&nbsp;                        states = new ArrayList&lt;&gt;();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                currentDirectedRealEdge = newDirectedRealEdge;</b>
&nbsp;            }
<b class="nc">&nbsp;            states.add(transitionAndState.state);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (currentDirectedRealEdge != null) {</b>
<b class="nc">&nbsp;            EdgeMatch edgeMatch = new EdgeMatch(currentDirectedRealEdge, states);</b>
<b class="nc">&nbsp;            edgeMatches.add(edgeMatch);</b>
&nbsp;        }
<b class="nc">&nbsp;        return edgeMatches;</b>
&nbsp;    }
&nbsp;
&nbsp;    private double gpxLength(List&lt;Observation&gt; gpxList) {
<b class="nc">&nbsp;        if (gpxList.isEmpty()) {</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            double gpxLength = 0;</b>
<b class="nc">&nbsp;            Observation prevEntry = gpxList.get(0);</b>
<b class="nc">&nbsp;            for (int i = 1; i &lt; gpxList.size(); i++) {</b>
<b class="nc">&nbsp;                Observation entry = gpxList.get(i);</b>
<b class="nc">&nbsp;                gpxLength += distanceCalc.calcDist(prevEntry.getPoint().lat, prevEntry.getPoint().lon, entry.getPoint().lat, entry.getPoint().lon);</b>
<b class="nc">&nbsp;                prevEntry = entry;</b>
&nbsp;            }
<b class="nc">&nbsp;            return gpxLength;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private boolean equalEdges(EdgeIteratorState edge1, EdgeIteratorState edge2) {
<b class="nc">&nbsp;        return edge1.getEdge() == edge2.getEdge()</b>
<b class="nc">&nbsp;                &amp;&amp; edge1.getBaseNode() == edge2.getBaseNode()</b>
<b class="nc">&nbsp;                &amp;&amp; edge1.getAdjNode() == edge2.getAdjNode();</b>
&nbsp;    }
&nbsp;
&nbsp;    private EdgeIteratorState resolveToRealEdge(EdgeIteratorState edgeIteratorState) {
<b class="nc">&nbsp;        if (queryGraph.isVirtualNode(edgeIteratorState.getBaseNode()) || queryGraph.isVirtualNode(edgeIteratorState.getAdjNode())) {</b>
<b class="nc">&nbsp;            return graph.getEdgeIteratorStateForKey(((VirtualEdgeIteratorState) edgeIteratorState).getOriginalEdgeKey());</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return edgeIteratorState;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public Map&lt;String, Object&gt; getStatistics() {
<b class="nc">&nbsp;        return statistics;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class MapMatchedPath extends Path {
&nbsp;        MapMatchedPath(Graph graph, Weighting weighting, List&lt;EdgeIteratorState&gt; edges) {
<b class="nc">&nbsp;            super(graph);</b>
<b class="nc">&nbsp;            int prevEdge = EdgeIterator.NO_EDGE;</b>
<b class="nc">&nbsp;            for (EdgeIteratorState edge : edges) {</b>
<b class="nc">&nbsp;                addDistance(edge.getDistance());</b>
<b class="nc">&nbsp;                addTime(GHUtility.calcMillisWithTurnMillis(weighting, edge, false, prevEdge));</b>
<b class="nc">&nbsp;                addEdge(edge.getEdge());</b>
<b class="nc">&nbsp;                prevEdge = edge.getEdge();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (edges.isEmpty()) {</b>
<b class="nc">&nbsp;                setFound(false);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                setFromNode(edges.get(0).getBaseNode());</b>
<b class="nc">&nbsp;                setFound(true);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Router {
&nbsp;        EdgeFilter getSnapFilter();
&nbsp;
&nbsp;        List&lt;Path&gt; calcPaths(QueryGraph queryGraph, int fromNode, int fromOutEdge, int[] toNodes, int[] toInEdges);
&nbsp;
&nbsp;        Weighting getWeighting();
&nbsp;
&nbsp;        default long getVisitedNodes() {
<b class="nc">&nbsp;            return 0L;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-09-30 17:20</div>
</div>
</body>
</html>
