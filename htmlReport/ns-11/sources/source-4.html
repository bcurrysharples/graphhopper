


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > CHPreparationGraph</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.graphhopper.routing.ch</a>
</div>

<h1>Coverage Summary for Class: CHPreparationGraph (com.graphhopper.routing.ch)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CHPreparationGraph</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/155)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CHPreparationGraph$EdgeBasedPrepareShortcut</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CHPreparationGraph$OrigEdgeIteratorImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CHPreparationGraph$OrigGraph</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CHPreparationGraph$OrigGraph$Builder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CHPreparationGraph$PrepareBaseEdge</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CHPreparationGraph$PrepareEdge</td>
  </tr>
  <tr>
    <td class="name">CHPreparationGraph$PrepareGraphEdgeExplorerImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CHPreparationGraph$PrepareShortcut</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CHPreparationGraph$TurnCostFunction</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/117)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/339)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Licensed to GraphHopper GmbH under one or more contributor
&nbsp; *  license agreements. See the NOTICE file distributed with this work for
&nbsp; *  additional information regarding copyright ownership.
&nbsp; *
&nbsp; *  GraphHopper GmbH licenses this file to you under the Apache License,
&nbsp; *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
&nbsp; *  compliance with the License. You may obtain a copy of the License at
&nbsp; *
&nbsp; *       http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package com.graphhopper.routing.ch;
&nbsp;
&nbsp;import com.carrotsearch.hppc.*;
&nbsp;import com.carrotsearch.hppc.sorting.IndirectComparator;
&nbsp;import com.carrotsearch.hppc.sorting.IndirectSort;
&nbsp;import com.graphhopper.routing.util.AllEdgesIterator;
&nbsp;import com.graphhopper.routing.weighting.Weighting;
&nbsp;import com.graphhopper.storage.Graph;
&nbsp;import com.graphhopper.util.GHUtility;
&nbsp;
&nbsp;import static com.graphhopper.util.ArrayUtil.zero;
&nbsp;
&nbsp;/**
&nbsp; * Graph data structure used for CH preparation. It allows caching weights, and edges that are not needed anymore
&nbsp; * (those adjacent to contracted nodes) can be removed (see {@link #disconnect}.
&nbsp; *
&nbsp; * @author easbar
&nbsp; */
&nbsp;public class CHPreparationGraph {
&nbsp;    private final int nodes;
&nbsp;    private final int edges;
&nbsp;    private final boolean edgeBased;
&nbsp;    private final TurnCostFunction turnCostFunction;
&nbsp;    // each edge/shortcut between nodes a/b is represented as a single object and we maintain two linked lists of such
&nbsp;    // objects for every node (one for outgoing edges and one for incoming edges).
&nbsp;    private PrepareEdge[] prepareEdgesOut;
&nbsp;    private PrepareEdge[] prepareEdgesIn;
&nbsp;    // todo: it should be possible to store the &#39;skipped node&#39; for each shortcut instead of storing the shortcut for
&nbsp;    //       each prepare edge. but this is a bit tricky for edge-based, because of our bidir shortcuts for node-based,
&nbsp;    //       and because basegraph has multi-edges. the advantage of storing the skipped node is that we could just write
&nbsp;    //       it to one of the skipped edges fields temporarily, so we would not need this array and save memory during
&nbsp;    //       the preparation.
&nbsp;    private IntArrayList shortcutsByPrepareEdges;
&nbsp;    // todo: maybe we can get rid of this
&nbsp;    private int[] degrees;
&nbsp;    private IntSet neighborSet;
&nbsp;    private OrigGraph origGraph;
&nbsp;    private OrigGraph.Builder origGraphBuilder;
&nbsp;    private int nextShortcutId;
&nbsp;    private boolean ready;
&nbsp;
&nbsp;    public static CHPreparationGraph nodeBased(int nodes, int edges) {
<b class="nc">&nbsp;        return new CHPreparationGraph(nodes, edges, false, (in, via, out) -&gt; 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static CHPreparationGraph edgeBased(int nodes, int edges, TurnCostFunction turnCostFunction) {
<b class="nc">&nbsp;        return new CHPreparationGraph(nodes, edges, true, turnCostFunction);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param nodes (fixed) number of nodes of the graph
&nbsp;     * @param edges the maximum number of (non-shortcut) edges in this graph. edges-1 is the maximum edge id that may
&nbsp;     *              be used.
&nbsp;     */
<b class="nc">&nbsp;    private CHPreparationGraph(int nodes, int edges, boolean edgeBased, TurnCostFunction turnCostFunction) {</b>
<b class="nc">&nbsp;        this.turnCostFunction = turnCostFunction;</b>
<b class="nc">&nbsp;        this.nodes = nodes;</b>
<b class="nc">&nbsp;        this.edges = edges;</b>
<b class="nc">&nbsp;        this.edgeBased = edgeBased;</b>
<b class="nc">&nbsp;        prepareEdgesOut = new PrepareEdge[nodes];</b>
<b class="nc">&nbsp;        prepareEdgesIn = new PrepareEdge[nodes];</b>
<b class="nc">&nbsp;        shortcutsByPrepareEdges = new IntArrayList();</b>
<b class="nc">&nbsp;        degrees = new int[nodes];</b>
<b class="nc">&nbsp;        origGraphBuilder = edgeBased ? new OrigGraph.Builder() : null;</b>
<b class="nc">&nbsp;        neighborSet = new IntScatterSet();</b>
<b class="nc">&nbsp;        nextShortcutId = edges;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static void buildFromGraph(CHPreparationGraph prepareGraph, Graph graph, Weighting weighting) {
<b class="nc">&nbsp;        if (graph.getNodes() != prepareGraph.getNodes())</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Cannot initialize from given graph. The number of nodes does not match: &quot; +</b>
<b class="nc">&nbsp;                    graph.getNodes() + &quot; vs. &quot; + prepareGraph.getNodes());</b>
<b class="nc">&nbsp;        if (graph.getEdges() != prepareGraph.getOriginalEdges())</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Cannot initialize from given graph. The number of edges does not match: &quot; +</b>
<b class="nc">&nbsp;                    graph.getEdges() + &quot; vs. &quot; + prepareGraph.getOriginalEdges());</b>
<b class="nc">&nbsp;        AllEdgesIterator iter = graph.getAllEdges();</b>
<b class="nc">&nbsp;        while (iter.next()) {</b>
<b class="nc">&nbsp;            double weightFwd = weighting.calcEdgeWeight(iter, false);</b>
<b class="nc">&nbsp;            double weightBwd = weighting.calcEdgeWeight(iter, true);</b>
<b class="nc">&nbsp;            prepareGraph.addEdge(iter.getBaseNode(), iter.getAdjNode(), iter.getEdge(), weightFwd, weightBwd);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        prepareGraph.prepareForContraction();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static TurnCostFunction buildTurnCostFunctionFromTurnCostStorage(Graph graph, Weighting weighting) {
&nbsp;        // At some point we used an optimized version where we copied the turn costs to sorted arrays
&nbsp;        // temporarily. This seemed to be around 25% faster according to measurements on the Bavaria
&nbsp;        // map, but for bigger maps the improvement is less, around 10% for planet. See also #2084
<b class="nc">&nbsp;        return weighting::calcTurnWeight;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getNodes() {
<b class="nc">&nbsp;        return nodes;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getOriginalEdges() {
<b class="nc">&nbsp;        return edges;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getDegree(int node) {
<b class="nc">&nbsp;        return degrees[node];</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addEdge(int from, int to, int edge, double weightFwd, double weightBwd) {
<b class="nc">&nbsp;        checkNotReady();</b>
<b class="nc">&nbsp;        if (from == to)</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Loop edges are no longer supported since #2862&quot;);</b>
<b class="nc">&nbsp;        boolean fwd = Double.isFinite(weightFwd);</b>
<b class="nc">&nbsp;        boolean bwd = Double.isFinite(weightBwd);</b>
<b class="nc">&nbsp;        if (!fwd &amp;&amp; !bwd)</b>
&nbsp;            return;
<b class="nc">&nbsp;        PrepareBaseEdge prepareEdge = new PrepareBaseEdge(edge, from, to, (float) weightFwd, (float) weightBwd);</b>
<b class="nc">&nbsp;        if (fwd) {</b>
<b class="nc">&nbsp;            addOutEdge(from, prepareEdge);</b>
<b class="nc">&nbsp;            addInEdge(to, prepareEdge);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (bwd &amp;&amp; from != to) {</b>
<b class="nc">&nbsp;            addOutEdge(to, prepareEdge);</b>
<b class="nc">&nbsp;            addInEdge(from, prepareEdge);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (edgeBased)</b>
<b class="nc">&nbsp;            origGraphBuilder.addEdge(from, to, edge, fwd, bwd);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int addShortcut(int from, int to, int origEdgeKeyFirst, int origEdgeKeyLast, int skipped1,
&nbsp;                           int skipped2, double weight, int origEdgeCount) {
<b class="nc">&nbsp;        checkReady();</b>
<b class="nc">&nbsp;        PrepareEdge prepareEdge = edgeBased</b>
<b class="nc">&nbsp;                ? new EdgeBasedPrepareShortcut(nextShortcutId, from, to, origEdgeKeyFirst, origEdgeKeyLast, weight, skipped1, skipped2, origEdgeCount)</b>
<b class="nc">&nbsp;                : new PrepareShortcut(nextShortcutId, from, to, weight, skipped1, skipped2, origEdgeCount);</b>
<b class="nc">&nbsp;        addOutEdge(from, prepareEdge);</b>
<b class="nc">&nbsp;        if (from != to)</b>
<b class="nc">&nbsp;            addInEdge(to, prepareEdge);</b>
<b class="nc">&nbsp;        return nextShortcutId++;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void prepareForContraction() {
<b class="nc">&nbsp;        checkNotReady();</b>
<b class="nc">&nbsp;        origGraph = edgeBased ? origGraphBuilder.build() : null;</b>
<b class="nc">&nbsp;        origGraphBuilder = null;</b>
<b class="nc">&nbsp;        ready = true;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setShortcutForPrepareEdge(int prepareEdge, int shortcut) {
<b class="nc">&nbsp;        int index = prepareEdge - edges;</b>
<b class="nc">&nbsp;        if (index &gt;= shortcutsByPrepareEdges.size())</b>
<b class="nc">&nbsp;            shortcutsByPrepareEdges.resize(index + 1);</b>
<b class="nc">&nbsp;        shortcutsByPrepareEdges.set(index, shortcut);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getShortcutForPrepareEdge(int prepareEdge) {
<b class="nc">&nbsp;        if (prepareEdge &lt; edges)</b>
<b class="nc">&nbsp;            return prepareEdge;</b>
<b class="nc">&nbsp;        int index = prepareEdge - edges;</b>
<b class="nc">&nbsp;        return shortcutsByPrepareEdges.get(index);</b>
&nbsp;    }
&nbsp;
&nbsp;    public PrepareGraphEdgeExplorer createOutEdgeExplorer() {
<b class="nc">&nbsp;        checkReady();</b>
<b class="nc">&nbsp;        return new PrepareGraphEdgeExplorerImpl(prepareEdgesOut, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public PrepareGraphEdgeExplorer createInEdgeExplorer() {
<b class="nc">&nbsp;        checkReady();</b>
<b class="nc">&nbsp;        return new PrepareGraphEdgeExplorerImpl(prepareEdgesIn, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public PrepareGraphOrigEdgeExplorer createOutOrigEdgeExplorer() {
<b class="nc">&nbsp;        checkReady();</b>
<b class="nc">&nbsp;        if (!edgeBased)</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;orig out explorer is not available for node-based graph&quot;);</b>
<b class="nc">&nbsp;        return origGraph.createOutOrigEdgeExplorer();</b>
&nbsp;    }
&nbsp;
&nbsp;    public PrepareGraphOrigEdgeExplorer createInOrigEdgeExplorer() {
<b class="nc">&nbsp;        checkReady();</b>
<b class="nc">&nbsp;        if (!edgeBased)</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;orig in explorer is not available for node-based graph&quot;);</b>
<b class="nc">&nbsp;        return origGraph.createInOrigEdgeExplorer();</b>
&nbsp;    }
&nbsp;
&nbsp;    public double getTurnWeight(int inEdgeKey, int viaNode, int outEdgeKey) {
<b class="nc">&nbsp;        return turnCostFunction.getTurnWeight(GHUtility.getEdgeFromEdgeKey(inEdgeKey), viaNode, GHUtility.getEdgeFromEdgeKey(outEdgeKey));</b>
&nbsp;    }
&nbsp;
&nbsp;    public IntContainer disconnect(int node) {
<b class="nc">&nbsp;        checkReady();</b>
&nbsp;        // we use this neighbor set to guarantee a deterministic order of the returned
&nbsp;        // node ids
<b class="nc">&nbsp;        neighborSet.clear();</b>
<b class="nc">&nbsp;        PrepareEdge currOut = prepareEdgesOut[node];</b>
<b class="nc">&nbsp;        while (currOut != null) {</b>
<b class="nc">&nbsp;            int adjNode = currOut.getNodeB();</b>
<b class="nc">&nbsp;            if (adjNode == node)</b>
<b class="nc">&nbsp;                adjNode = currOut.getNodeA();</b>
<b class="nc">&nbsp;            if (adjNode == node) {</b>
&nbsp;                // this is a loop
<b class="nc">&nbsp;                currOut = currOut.getNextOut(node);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            removeInEdge(adjNode, currOut);</b>
<b class="nc">&nbsp;            neighborSet.add(adjNode);</b>
<b class="nc">&nbsp;            currOut = currOut.getNextOut(node);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        PrepareEdge currIn = prepareEdgesIn[node];</b>
<b class="nc">&nbsp;        while (currIn != null) {</b>
<b class="nc">&nbsp;            int adjNode = currIn.getNodeB();</b>
<b class="nc">&nbsp;            if (adjNode == node)</b>
<b class="nc">&nbsp;                adjNode = currIn.getNodeA();</b>
<b class="nc">&nbsp;            if (adjNode == node) {</b>
&nbsp;                // this is a loop
<b class="nc">&nbsp;                currIn = currIn.getNextIn(node);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            removeOutEdge(adjNode, currIn);</b>
<b class="nc">&nbsp;            neighborSet.add(adjNode);</b>
<b class="nc">&nbsp;            currIn = currIn.getNextIn(node);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        prepareEdgesOut[node] = null;</b>
<b class="nc">&nbsp;        prepareEdgesIn[node] = null;</b>
<b class="nc">&nbsp;        degrees[node] = 0;</b>
<b class="nc">&nbsp;        return neighborSet;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void removeOutEdge(int node, PrepareEdge prepareEdge) {
<b class="nc">&nbsp;        PrepareEdge prevOut = null;</b>
<b class="nc">&nbsp;        PrepareEdge currOut = prepareEdgesOut[node];</b>
<b class="nc">&nbsp;        while (currOut != null) {</b>
<b class="nc">&nbsp;            if (currOut == prepareEdge) {</b>
<b class="nc">&nbsp;                if (prevOut == null) {</b>
<b class="nc">&nbsp;                    prepareEdgesOut[node] = currOut.getNextOut(node);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    prevOut.setNextOut(node, currOut.getNextOut(node));</b>
&nbsp;                }
<b class="nc">&nbsp;                degrees[node]--;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                prevOut = currOut;</b>
&nbsp;            }
<b class="nc">&nbsp;            currOut = currOut.getNextOut(node);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void removeInEdge(int node, PrepareEdge prepareEdge) {
<b class="nc">&nbsp;        PrepareEdge prevIn = null;</b>
<b class="nc">&nbsp;        PrepareEdge currIn = prepareEdgesIn[node];</b>
<b class="nc">&nbsp;        while (currIn != null) {</b>
<b class="nc">&nbsp;            if (currIn == prepareEdge) {</b>
<b class="nc">&nbsp;                if (prevIn == null) {</b>
<b class="nc">&nbsp;                    prepareEdgesIn[node] = currIn.getNextIn(node);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    prevIn.setNextIn(node, currIn.getNextIn(node));</b>
&nbsp;                }
<b class="nc">&nbsp;                degrees[node]--;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                prevIn = currIn;</b>
&nbsp;            }
<b class="nc">&nbsp;            currIn = currIn.getNextIn(node);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void close() {
<b class="nc">&nbsp;        checkReady();</b>
<b class="nc">&nbsp;        prepareEdgesOut = null;</b>
<b class="nc">&nbsp;        prepareEdgesIn = null;</b>
<b class="nc">&nbsp;        shortcutsByPrepareEdges = null;</b>
<b class="nc">&nbsp;        degrees = null;</b>
<b class="nc">&nbsp;        neighborSet = null;</b>
<b class="nc">&nbsp;        if (edgeBased)</b>
<b class="nc">&nbsp;            origGraph = null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addOutEdge(int node, PrepareEdge prepareEdge) {
<b class="nc">&nbsp;        prepareEdge.setNextOut(node, prepareEdgesOut[node]);</b>
<b class="nc">&nbsp;        prepareEdgesOut[node] = prepareEdge;</b>
<b class="nc">&nbsp;        degrees[node]++;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addInEdge(int node, PrepareEdge prepareEdge) {
<b class="nc">&nbsp;        prepareEdge.setNextIn(node, prepareEdgesIn[node]);</b>
<b class="nc">&nbsp;        prepareEdgesIn[node] = prepareEdge;</b>
<b class="nc">&nbsp;        degrees[node]++;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void checkReady() {
<b class="nc">&nbsp;        if (!ready)</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;You need to call prepareForContraction() before calling this method&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void checkNotReady() {
<b class="nc">&nbsp;        if (ready)</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;You cannot call this method after calling prepareForContraction()&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @FunctionalInterface
&nbsp;    public interface TurnCostFunction {
&nbsp;        double getTurnWeight(int inEdge, int viaNode, int outEdge);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class PrepareGraphEdgeExplorerImpl implements PrepareGraphEdgeExplorer, PrepareGraphEdgeIterator {</b>
&nbsp;        private final PrepareEdge[] prepareEdges;
&nbsp;        private final boolean reverse;
<b class="nc">&nbsp;        private int node = -1;</b>
&nbsp;        private PrepareEdge currEdge;
&nbsp;        private PrepareEdge nextEdge;
&nbsp;
<b class="nc">&nbsp;        PrepareGraphEdgeExplorerImpl(PrepareEdge[] prepareEdges, boolean reverse) {</b>
<b class="nc">&nbsp;            this.prepareEdges = prepareEdges;</b>
<b class="nc">&nbsp;            this.reverse = reverse;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PrepareGraphEdgeIterator setBaseNode(int node) {
<b class="nc">&nbsp;            this.node = node;</b>
<b class="nc">&nbsp;            currEdge = null;</b>
<b class="nc">&nbsp;            nextEdge = prepareEdges[node];</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean next() {
<b class="nc">&nbsp;            currEdge = nextEdge;</b>
<b class="nc">&nbsp;            if (currEdge == null)</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            nextEdge = reverse ? currEdge.getNextIn(node) : currEdge.getNextOut(node);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getBaseNode() {
<b class="nc">&nbsp;            return node;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getAdjNode() {
<b class="nc">&nbsp;            return nodeAisBase() ? currEdge.getNodeB() : currEdge.getNodeA();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getPrepareEdge() {
<b class="nc">&nbsp;            return currEdge.getPrepareEdge();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isShortcut() {
<b class="nc">&nbsp;            return currEdge.isShortcut();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyFirst() {
<b class="nc">&nbsp;            return nodeAisBase() ? currEdge.getOrigEdgeKeyFirstAB() : currEdge.getOrigEdgeKeyFirstBA();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyLast() {
<b class="nc">&nbsp;            return nodeAisBase() ? currEdge.getOrigEdgeKeyLastAB() : currEdge.getOrigEdgeKeyLastBA();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getSkipped1() {
<b class="nc">&nbsp;            return currEdge.getSkipped1();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getSkipped2() {
<b class="nc">&nbsp;            return currEdge.getSkipped2();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public double getWeight() {
<b class="nc">&nbsp;            if (nodeAisBase()) {</b>
<b class="nc">&nbsp;                return reverse ? currEdge.getWeightBA() : currEdge.getWeightAB();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return reverse ? currEdge.getWeightAB() : currEdge.getWeightBA();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeCount() {
<b class="nc">&nbsp;            return currEdge.getOrigEdgeCount();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setSkippedEdges(int skipped1, int skipped2) {
<b class="nc">&nbsp;            currEdge.setSkipped1(skipped1);</b>
<b class="nc">&nbsp;            currEdge.setSkipped2(skipped2);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setWeight(double weight) {
<b class="nc">&nbsp;            assert Double.isFinite(weight);</b>
<b class="nc">&nbsp;            currEdge.setWeight(weight);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setOrigEdgeCount(int origEdgeCount) {
<b class="nc">&nbsp;            currEdge.setOrigEdgeCount(origEdgeCount);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return currEdge == null ? &quot;not_started&quot; : currEdge.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        private boolean nodeAisBase() {
&nbsp;            // in some cases we need to determine which direction of the (bidirectional) edge we want
<b class="nc">&nbsp;            return currEdge.getNodeA() == node;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    interface PrepareEdge {
&nbsp;        boolean isShortcut();
&nbsp;
&nbsp;        int getPrepareEdge();
&nbsp;
&nbsp;        int getNodeA();
&nbsp;
&nbsp;        int getNodeB();
&nbsp;
&nbsp;        double getWeightAB();
&nbsp;
&nbsp;        double getWeightBA();
&nbsp;
&nbsp;        int getOrigEdgeKeyFirstAB();
&nbsp;
&nbsp;        int getOrigEdgeKeyFirstBA();
&nbsp;
&nbsp;        int getOrigEdgeKeyLastAB();
&nbsp;
&nbsp;        int getOrigEdgeKeyLastBA();
&nbsp;
&nbsp;        int getSkipped1();
&nbsp;
&nbsp;        int getSkipped2();
&nbsp;
&nbsp;        int getOrigEdgeCount();
&nbsp;
&nbsp;        void setSkipped1(int skipped1);
&nbsp;
&nbsp;        void setSkipped2(int skipped2);
&nbsp;
&nbsp;        void setWeight(double weight);
&nbsp;
&nbsp;        void setOrigEdgeCount(int origEdgeCount);
&nbsp;
&nbsp;        PrepareEdge getNextOut(int base);
&nbsp;
&nbsp;        void setNextOut(int base, PrepareEdge prepareEdge);
&nbsp;
&nbsp;        PrepareEdge getNextIn(int base);
&nbsp;
&nbsp;        void setNextIn(int base, PrepareEdge prepareEdge);
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public static class PrepareBaseEdge implements PrepareEdge {
&nbsp;        private final int prepareEdge;
&nbsp;        private final int nodeA;
&nbsp;        private final int nodeB;
&nbsp;        private final float weightAB;
&nbsp;        private final float weightBA;
&nbsp;        private PrepareEdge nextOutA;
&nbsp;        private PrepareEdge nextOutB;
&nbsp;        private PrepareEdge nextInA;
&nbsp;        private PrepareEdge nextInB;
&nbsp;
<b class="nc">&nbsp;        public PrepareBaseEdge(int prepareEdge, int nodeA, int nodeB, float weightAB, float weightBA) {</b>
<b class="nc">&nbsp;            this.prepareEdge = prepareEdge;</b>
<b class="nc">&nbsp;            this.nodeA = nodeA;</b>
<b class="nc">&nbsp;            this.nodeB = nodeB;</b>
<b class="nc">&nbsp;            this.weightAB = weightAB;</b>
<b class="nc">&nbsp;            this.weightBA = weightBA;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isShortcut() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getPrepareEdge() {
<b class="nc">&nbsp;            return prepareEdge;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getNodeA() {
<b class="nc">&nbsp;            return nodeA;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getNodeB() {
<b class="nc">&nbsp;            return nodeB;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public double getWeightAB() {
<b class="nc">&nbsp;            return weightAB;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public double getWeightBA() {
<b class="nc">&nbsp;            return weightBA;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyFirstAB() {
<b class="nc">&nbsp;            return GHUtility.createEdgeKey(prepareEdge, false);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyFirstBA() {
<b class="nc">&nbsp;            return GHUtility.createEdgeKey(prepareEdge, true);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyLastAB() {
<b class="nc">&nbsp;            return getOrigEdgeKeyFirstAB();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyLastBA() {
<b class="nc">&nbsp;            return getOrigEdgeKeyFirstBA();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getSkipped1() {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getSkipped2() {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeCount() {
<b class="nc">&nbsp;            return 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setSkipped1(int skipped1) {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setSkipped2(int skipped2) {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setWeight(double weight) {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setOrigEdgeCount(int origEdgeCount) {
<b class="nc">&nbsp;            throw new UnsupportedOperationException();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PrepareEdge getNextOut(int base) {
<b class="nc">&nbsp;            if (base == nodeA)</b>
<b class="nc">&nbsp;                return nextOutA;</b>
<b class="nc">&nbsp;            else if (base == nodeB)</b>
<b class="nc">&nbsp;                return nextOutB;</b>
&nbsp;            else
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot get next out edge as the given base &quot; + base + &quot; is not adjacent to the current edge&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setNextOut(int base, PrepareEdge prepareEdge) {
<b class="nc">&nbsp;            if (base == nodeA)</b>
<b class="nc">&nbsp;                nextOutA = prepareEdge;</b>
<b class="nc">&nbsp;            else if (base == nodeB)</b>
<b class="nc">&nbsp;                nextOutB = prepareEdge;</b>
&nbsp;            else
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot set next out edge as the given base &quot; + base + &quot; is not adjacent to the current edge&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PrepareEdge getNextIn(int base) {
<b class="nc">&nbsp;            if (base == nodeA)</b>
<b class="nc">&nbsp;                return nextInA;</b>
<b class="nc">&nbsp;            else if (base == nodeB)</b>
<b class="nc">&nbsp;                return nextInB;</b>
&nbsp;            else
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot get next in edge as the given base &quot; + base + &quot; is not adjacent to the current edge&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setNextIn(int base, PrepareEdge prepareEdge) {
<b class="nc">&nbsp;            if (base == nodeA)</b>
<b class="nc">&nbsp;                nextInA = prepareEdge;</b>
<b class="nc">&nbsp;            else if (base == nodeB)</b>
<b class="nc">&nbsp;                nextInB = prepareEdge;</b>
&nbsp;            else
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot set next in edge as the given base &quot; + base + &quot; is not adjacent to the current edge&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return nodeA + &quot;-&quot; + nodeB + &quot; (&quot; + prepareEdge + &quot;) &quot; + weightAB + &quot; &quot; + weightBA;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class PrepareShortcut implements PrepareEdge {</b>
&nbsp;        private final int prepareEdge;
&nbsp;        private final int from;
&nbsp;        private final int to;
&nbsp;        private double weight;
&nbsp;        private int skipped1;
&nbsp;        private int skipped2;
&nbsp;        private int origEdgeCount;
&nbsp;        private PrepareEdge nextOut;
&nbsp;        private PrepareEdge nextIn;
&nbsp;
<b class="nc">&nbsp;        private PrepareShortcut(int prepareEdge, int from, int to, double weight, int skipped1, int skipped2, int origEdgeCount) {</b>
<b class="nc">&nbsp;            this.prepareEdge = prepareEdge;</b>
<b class="nc">&nbsp;            this.from = from;</b>
<b class="nc">&nbsp;            this.to = to;</b>
<b class="nc">&nbsp;            assert Double.isFinite(weight);</b>
<b class="nc">&nbsp;            this.weight = weight;</b>
<b class="nc">&nbsp;            this.skipped1 = skipped1;</b>
<b class="nc">&nbsp;            this.skipped2 = skipped2;</b>
<b class="nc">&nbsp;            this.origEdgeCount = origEdgeCount;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isShortcut() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getPrepareEdge() {
<b class="nc">&nbsp;            return prepareEdge;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getNodeA() {
<b class="nc">&nbsp;            return from;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getNodeB() {
<b class="nc">&nbsp;            return to;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public double getWeightAB() {
<b class="nc">&nbsp;            return weight;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public double getWeightBA() {
<b class="nc">&nbsp;            return weight;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyFirstAB() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Not supported for node-based shortcuts&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyFirstBA() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Not supported for node-based shortcuts&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyLastAB() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Not supported for node-based shortcuts&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyLastBA() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Not supported for node-based shortcuts&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getSkipped1() {
<b class="nc">&nbsp;            return skipped1;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getSkipped2() {
<b class="nc">&nbsp;            return skipped2;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeCount() {
<b class="nc">&nbsp;            return origEdgeCount;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setSkipped1(int skipped1) {
<b class="nc">&nbsp;            this.skipped1 = skipped1;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setSkipped2(int skipped2) {
<b class="nc">&nbsp;            this.skipped2 = skipped2;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setWeight(double weight) {
<b class="nc">&nbsp;            this.weight = weight;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setOrigEdgeCount(int origEdgeCount) {
<b class="nc">&nbsp;            this.origEdgeCount = origEdgeCount;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PrepareEdge getNextOut(int base) {
<b class="nc">&nbsp;            return nextOut;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setNextOut(int base, PrepareEdge prepareEdge) {
<b class="nc">&nbsp;            this.nextOut = prepareEdge;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PrepareEdge getNextIn(int base) {
<b class="nc">&nbsp;            return nextIn;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void setNextIn(int base, PrepareEdge prepareEdge) {
<b class="nc">&nbsp;            this.nextIn = prepareEdge;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return from + &quot;-&quot; + to + &quot; &quot; + weight;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class EdgeBasedPrepareShortcut extends PrepareShortcut {
&nbsp;        // we use this subclass to save some memory for node-based where these are not needed
&nbsp;        private final int origEdgeKeyFirst;
&nbsp;        private final int origEdgeKeyLast;
&nbsp;
&nbsp;        public EdgeBasedPrepareShortcut(int prepareEdge, int from, int to, int origEdgeKeyFirst, int origEdgeKeyLast,
&nbsp;                                        double weight, int skipped1, int skipped2, int origEdgeCount) {
<b class="nc">&nbsp;            super(prepareEdge, from, to, weight, skipped1, skipped2, origEdgeCount);</b>
<b class="nc">&nbsp;            this.origEdgeKeyFirst = origEdgeKeyFirst;</b>
<b class="nc">&nbsp;            this.origEdgeKeyLast = origEdgeKeyLast;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyFirstAB() {
<b class="nc">&nbsp;            return origEdgeKeyFirst;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyFirstBA() {
<b class="nc">&nbsp;            return origEdgeKeyFirst;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyLastAB() {
<b class="nc">&nbsp;            return origEdgeKeyLast;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyLastBA() {
<b class="nc">&nbsp;            return origEdgeKeyLast;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return getNodeA() + &quot;-&quot; + getNodeB() + &quot; (&quot; + origEdgeKeyFirst + &quot;, &quot; + origEdgeKeyLast + &quot;) &quot; + getWeightAB();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This helper graph can be used to quickly obtain the edge-keys of the edges of a node. It is only used for
&nbsp;     * edge-based CH. In principle, we could use base graph for this, but it turned out it is faster to use this
&nbsp;     * graph (because it does not need to read all the edge flags to determine the access flags).
&nbsp;     */
&nbsp;    static class OrigGraph {
&nbsp;        // we store a list of &#39;edges&#39; in the format: adjNode|fwdAccess|edgeKey|bwdAccess, we use two ints for each edge
&nbsp;        private final IntArrayList adjNodesAndFwdFlags;
&nbsp;        private final IntArrayList keysAndBwdFlags;
&nbsp;        // for each node we store the index at which the edges for this node begin in the above edge list
&nbsp;        private final IntArrayList firstEdgesByNode;
&nbsp;
<b class="nc">&nbsp;        private OrigGraph(IntArrayList firstEdgesByNode, IntArrayList adjNodesAndFwdFlags, IntArrayList keysAndBwdFlags) {</b>
<b class="nc">&nbsp;            this.firstEdgesByNode = firstEdgesByNode;</b>
<b class="nc">&nbsp;            this.adjNodesAndFwdFlags = adjNodesAndFwdFlags;</b>
<b class="nc">&nbsp;            this.keysAndBwdFlags = keysAndBwdFlags;</b>
&nbsp;        }
&nbsp;
&nbsp;        PrepareGraphOrigEdgeExplorer createOutOrigEdgeExplorer() {
<b class="nc">&nbsp;            return new OrigEdgeIteratorImpl(this, false);</b>
&nbsp;        }
&nbsp;
&nbsp;        PrepareGraphOrigEdgeExplorer createInOrigEdgeExplorer() {
<b class="nc">&nbsp;            return new OrigEdgeIteratorImpl(this, true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        static class Builder {</b>
<b class="nc">&nbsp;            private final IntArrayList fromNodes = new IntArrayList();</b>
<b class="nc">&nbsp;            private final IntArrayList toNodesAndFwdFlags = new IntArrayList();</b>
<b class="nc">&nbsp;            private final IntArrayList keysAndBwdFlags = new IntArrayList();</b>
<b class="nc">&nbsp;            private int maxFrom = -1;</b>
<b class="nc">&nbsp;            private int maxTo = -1;</b>
&nbsp;
&nbsp;            void addEdge(int from, int to, int edge, boolean fwd, boolean bwd) {
<b class="nc">&nbsp;                fromNodes.add(from);</b>
<b class="nc">&nbsp;                toNodesAndFwdFlags.add(getIntWithFlag(to, fwd));</b>
<b class="nc">&nbsp;                keysAndBwdFlags.add(getIntWithFlag(GHUtility.createEdgeKey(edge, false), bwd));</b>
<b class="nc">&nbsp;                maxFrom = Math.max(maxFrom, from);</b>
<b class="nc">&nbsp;                maxTo = Math.max(maxTo, to);</b>
&nbsp;
<b class="nc">&nbsp;                fromNodes.add(to);</b>
<b class="nc">&nbsp;                toNodesAndFwdFlags.add(getIntWithFlag(from, bwd));</b>
<b class="nc">&nbsp;                keysAndBwdFlags.add(getIntWithFlag(GHUtility.createEdgeKey(edge, true), fwd));</b>
<b class="nc">&nbsp;                maxFrom = Math.max(maxFrom, to);</b>
<b class="nc">&nbsp;                maxTo = Math.max(maxTo, from);</b>
&nbsp;            }
&nbsp;
&nbsp;            OrigGraph build() {
<b class="nc">&nbsp;                int[] sortOrder = IndirectSort.mergesort(0, fromNodes.elementsCount, new IndirectComparator.AscendingIntComparator(fromNodes.buffer));</b>
<b class="nc">&nbsp;                sortAndTrim(fromNodes, sortOrder);</b>
<b class="nc">&nbsp;                sortAndTrim(toNodesAndFwdFlags, sortOrder);</b>
<b class="nc">&nbsp;                sortAndTrim(keysAndBwdFlags, sortOrder);</b>
<b class="nc">&nbsp;                return new OrigGraph(buildFirstEdgesByNode(), toNodesAndFwdFlags, keysAndBwdFlags);</b>
&nbsp;            }
&nbsp;
&nbsp;            private static int getIntWithFlag(int val, boolean access) {
&nbsp;                // we use only 31 bits for the val and store an access flag along with the same int
&nbsp;                // this allows for a maximum of 1073mio edges (and 2147mio nodes) in base graph
&nbsp;                // which is still enough for planet-wide OSM, but if we exceed this limit we need to
&nbsp;                // move the access bits somewhere else or store the edge instead of the val as we
&nbsp;                // did before #2567 (only here)
<b class="nc">&nbsp;                if (val &lt; 0)</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Maximum node or edge key exceeded: &quot; + val + &quot;, max: &quot; + Integer.MAX_VALUE);</b>
<b class="nc">&nbsp;                val &lt;&lt;= 1;</b>
<b class="nc">&nbsp;                if (access)</b>
<b class="nc">&nbsp;                    val++;</b>
<b class="nc">&nbsp;                return val;</b>
&nbsp;            }
&nbsp;
&nbsp;            private IntArrayList buildFirstEdgesByNode() {
&nbsp;                // it is assumed the edges have been sorted already
<b class="nc">&nbsp;                final int numFroms = maxFrom + 1;</b>
<b class="nc">&nbsp;                final int numEdges = fromNodes.size();</b>
&nbsp;
<b class="nc">&nbsp;                IntArrayList firstEdgesByNode = zero(numFroms + 1);</b>
<b class="nc">&nbsp;                if (numFroms == 0) {</b>
<b class="nc">&nbsp;                    firstEdgesByNode.set(0, numEdges);</b>
<b class="nc">&nbsp;                    return firstEdgesByNode;</b>
&nbsp;                }
<b class="nc">&nbsp;                int edgeIndex = 0;</b>
<b class="nc">&nbsp;                for (int from = 0; from &lt; numFroms; from++) {</b>
<b class="nc">&nbsp;                    while (edgeIndex &lt; numEdges &amp;&amp; fromNodes.get(edgeIndex) &lt; from) {</b>
<b class="nc">&nbsp;                        edgeIndex++;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    firstEdgesByNode.set(from, edgeIndex);</b>
&nbsp;                }
<b class="nc">&nbsp;                firstEdgesByNode.set(numFroms, numEdges);</b>
<b class="nc">&nbsp;                return firstEdgesByNode;</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class OrigEdgeIteratorImpl implements PrepareGraphOrigEdgeExplorer, PrepareGraphOrigEdgeIterator {
&nbsp;        private final OrigGraph graph;
&nbsp;        private final boolean reverse;
&nbsp;        private int node;
&nbsp;        private int endEdge;
&nbsp;        private int index;
&nbsp;
<b class="nc">&nbsp;        public OrigEdgeIteratorImpl(OrigGraph graph, boolean reverse) {</b>
<b class="nc">&nbsp;            this.graph = graph;</b>
<b class="nc">&nbsp;            this.reverse = reverse;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public PrepareGraphOrigEdgeIterator setBaseNode(int node) {
<b class="nc">&nbsp;            this.node = node;</b>
<b class="nc">&nbsp;            index = graph.firstEdgesByNode.get(node) - 1;</b>
<b class="nc">&nbsp;            endEdge = graph.firstEdgesByNode.get(node + 1);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean next() {
&nbsp;            while (true) {
<b class="nc">&nbsp;                index++;</b>
<b class="nc">&nbsp;                if (index &gt;= endEdge)</b>
<b class="nc">&nbsp;                    return false;</b>
<b class="nc">&nbsp;                if (hasAccess())</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getBaseNode() {
<b class="nc">&nbsp;            return node;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getAdjNode() {
<b class="nc">&nbsp;            return graph.adjNodesAndFwdFlags.get(index) &gt;&gt;&gt; 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyFirst() {
<b class="nc">&nbsp;            return graph.keysAndBwdFlags.get(index) &gt;&gt;&gt; 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int getOrigEdgeKeyLast() {
<b class="nc">&nbsp;            return getOrigEdgeKeyFirst();</b>
&nbsp;        }
&nbsp;
&nbsp;        private boolean hasAccess() {
<b class="nc">&nbsp;            int e = reverse</b>
<b class="nc">&nbsp;                    ? graph.keysAndBwdFlags.get(index)</b>
<b class="nc">&nbsp;                    : graph.adjNodesAndFwdFlags.get(index);</b>
<b class="nc">&nbsp;            return (e &amp; 0b01) == 0b01;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return getBaseNode() + &quot;-&quot; + getAdjNode() + &quot;(&quot; + getOrigEdgeKeyFirst() + &quot;)&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static void sortAndTrim(IntArrayList arr, int[] sortOrder) {
<b class="nc">&nbsp;        arr.buffer = applySortOrder(sortOrder, arr.buffer);</b>
<b class="nc">&nbsp;        arr.elementsCount = arr.buffer.length;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int[] applySortOrder(int[] sortOrder, int[] arr) {
<b class="nc">&nbsp;        if (sortOrder.length &gt; arr.length) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;sort order must not be shorter than array&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        int[] result = new int[sortOrder.length];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; result.length; i++) {</b>
<b class="nc">&nbsp;            result[i] = arr[sortOrder[i]];</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-10-05 17:25</div>
</div>
</body>
</html>
